var documenterSearchIndex = {"docs":
[{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"using TensorCategories, Oscar","category":"page"},{"location":"ConcreteExamples/VectorSpaces/#Vector-Space-Categories","page":"Graded Vector Spaces","title":"Vector Space Categories","text":"","category":"section"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"Vector spaces in TensorCategories are of the abstract type","category":"page"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"abstract type VectorSpaceObject <: Object end","category":"page"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"All objects with vector space structure like hom-spaces are and should be implemented as a subtype of this type. They always need the following fields:","category":"page"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"basis::Vector\nparent::Category","category":"page"},{"location":"ConcreteExamples/VectorSpaces/#Finite-Dimensional-VectorSpaces","page":"Graded Vector Spaces","title":"Finite Dimensional VectorSpaces","text":"","category":"section"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"The simplest example to provide are the finite dimensional vector spaces over a field. This category has type","category":"page"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"VectorSpaces <: TensorCategory","category":"page"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"and can be constructed like so:","category":"page"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"F = GF(5,2)\nVec = VectorSpaces(F)","category":"page"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"Objects of this category are of the type","category":"page"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"VSObject <: VectorSpaceObject","category":"page"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"Every vector space object is defined by a basis and a base field provided by the parent category.","category":"page"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"VectorSpaceObject\nVectorSpaceObject(::VectorSpaces,::Int)","category":"page"},{"location":"ConcreteExamples/VectorSpaces/#TensorCategories.VectorSpaceObject","page":"Graded Vector Spaces","title":"TensorCategories.VectorSpaceObject","text":"VectorSpaceObject\n\nAn object in the category of finite dimensional vector spaces.\n\n\n\n\n\n","category":"type"},{"location":"ConcreteExamples/VectorSpaces/#TensorCategories.VectorSpaceObject-Tuple{VectorSpaces, Int64}","page":"Graded Vector Spaces","title":"TensorCategories.VectorSpaceObject","text":"VectorSpaceObject(Vec::VectorSpaces, n::Int64)\nVectorSpaceObject(K::Field, n::Int)\nVectorSpaceObject(Vec::VectorSpaces, basis::Vector)\nVectorSpaceObject(K::Field, basis::Vector)\n\nThe n-dimensional vector space with basis v1,..,vn (or other specified basis)\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"Morphisms in this Category are defined only by matrices of matching dimensions. They are typed as","category":"page"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"VSMorphism <: Morphism","category":"page"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"and constructed giving a domain, codomain and matrix element.","category":"page"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"morphism(::VectorSpaceObject, ::VectorSpaceObject, ::MatElem)","category":"page"},{"location":"ConcreteExamples/VectorSpaces/#Oscar.morphism-Tuple{VectorSpaceObject, VectorSpaceObject, MatElem}","page":"Graded Vector Spaces","title":"Oscar.morphism","text":"morphism(X::VectorSpaceObject, Y::VectorSpaceObject, m::MatElem)\n\nReturn a morphism in the category of vector spaces defined by m.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#Graded-Vector-Spaces","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"","category":"section"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"Very similar we have the category of finite dimensional (twisted) G-graded vector spaces for a finite group G. We have the type","category":"page"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"GradedVectorSpaces <: VectorSpaces","category":"page"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"and they are constructed in straightforward manner","category":"page"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"G = symmetric_group(6)\nVecG = graded_vector_spaces(G)","category":"page"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"To add a non-trivial associator (twist) there is another constructor. ","category":"page"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"twisted_graded_vector_spaces","category":"page"},{"location":"ConcreteExamples/VectorSpaces/#TensorCategories.twisted_graded_vector_spaces","page":"Graded Vector Spaces","title":"TensorCategories.twisted_graded_vector_spaces","text":"twisted_graded_vector_spaces(G::Group, i::Int)\n\nConstruct the category of twisted graded vectorspaces with the i-th 3-cocycle.\n\n\n\n\n\n","category":"function"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"Graded vector spaces decompose into direct sums of vector spaces for each element in G.","category":"page"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"GVSObject <: VectorSpaceObject","category":"page"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"G = symmetric_group(5)\ng,s = gens(G)\nV1 = VectorSpaceObject(QQ,5)\nV2 = VectorSpaceObject(QQ, [:v, :w])\nW = VectorSpaceObject(g => V1, s => V2, g*s => V1⊗V2)","category":"page"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"Morphisms are implemented analogously by pairs of group elements and vector space objects.","category":"page"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"GVSMorphism <: Morphism","category":"page"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"The constructor is given by ","category":"page"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"morphism(::GVSObject, ::GVSObject,::MatElem)","category":"page"},{"location":"ConcreteExamples/VectorSpaces/#Oscar.morphism-Tuple{GVSObject, GVSObject, MatElem}","page":"Graded Vector Spaces","title":"Oscar.morphism","text":"function morphism(V::GVSObject, Y::GVSObject, m::MatElem)\n\nReturn the morphism V  Wdefined by m.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#Functionality","page":"Graded Vector Spaces","title":"Functionality","text":"","category":"section"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"(Graded) vector spaces form a fusion category. Thus the methods for direct sums, tensor products, dual, one and zero object are all implemented.","category":"page"},{"location":"ConcreteExamples/VectorSpaces/","page":"Graded Vector Spaces","title":"Graded Vector Spaces","text":"Modules = [TensorCategories]\nPages = [\"VectorSpaces.jl\"]\nOrder = [:function]","category":"page"},{"location":"ConcreteExamples/VectorSpaces/#AbstractAlgebra.Generic.dim-Tuple{VectorSpaceObject}","page":"Graded Vector Spaces","title":"AbstractAlgebra.Generic.dim","text":"dim(V::VectorSpaceObject) = length(V.basis)\n\nReturn the vector space dimension of V.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#AbstractAlgebra.direct_sum-Tuple{GVSObject, GVSObject}","page":"Graded Vector Spaces","title":"AbstractAlgebra.direct_sum","text":"function direct_sum(V::GVSObject, W::GVSObject)\n\nReturn the direct sum object VW.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#AbstractAlgebra.direct_sum-Tuple{VectorSpaceMorphism, VectorSpaceMorphism}","page":"Graded Vector Spaces","title":"AbstractAlgebra.direct_sum","text":"direct_sum(f::VectorSpaceMorphism{T},g::VectorSpaceMorphism{T}) where T\n\nReturn the direct sum of morphisms of vector spaces.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#AbstractAlgebra.direct_sum-Tuple{VectorSpaceObject, VectorSpaceObject}","page":"Graded Vector Spaces","title":"AbstractAlgebra.direct_sum","text":"direct_sum(X::VectorSpaceObject{T}, Y::VectorSpaceObject{T}) where {T}\n\nDirect sum of vector spaces together with the embedding morphisms.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#AbstractAlgebra.is_isomorphic-Tuple{GVSObject, GVSObject}","page":"Graded Vector Spaces","title":"AbstractAlgebra.is_isomorphic","text":"function is_isomorphic(V::GVSObject, W::GVSObject)\n\nCheck whether Vand Ware isomorphic as G-graded vector spaces and return an isomorphism in the positive case.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#AbstractAlgebra.is_isomorphic-Tuple{VectorSpaceObject, VectorSpaceObject}","page":"Graded Vector Spaces","title":"AbstractAlgebra.is_isomorphic","text":"is_isomorphic(V::VSObject, W::VSObject)\n\nCheck whether V and Ware isomorphic. Return the isomorphisms if existent.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#AbstractAlgebra.kernel-Tuple{GVSMorphism}","page":"Graded Vector Spaces","title":"AbstractAlgebra.kernel","text":"function kernel(f::GVSMorphism)\n\nReturn the graded vector space kernel of f.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#Base.one-Tuple{GradedVectorSpaces}","page":"Graded Vector Spaces","title":"Base.one","text":"function one(C::GradedVectorSpaces)\n\nReturn k as the one dimensional graded vector space.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#Base.one-Tuple{VectorSpaces}","page":"Graded Vector Spaces","title":"Base.one","text":"one(Vec::VectorSpaces) = VectorSpaceObject(base_ring(Vec),1)\n\nReturn the one-dimensional vector space.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#Base.zero-Tuple{GradedVectorSpaces}","page":"Graded Vector Spaces","title":"Base.zero","text":"function zero(C::GradedVectorSpaces)\n\nReturn the zero diemsnional graded vector space.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#Base.zero-Tuple{VectorSpaces}","page":"Graded Vector Spaces","title":"Base.zero","text":"zero(Vec::VectorSpaces) = VectorSpaceObject(base_ring(Vec), 0)\n\nReturn the zero-dimensional vector space.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#Hecke.cokernel-Tuple{GVSMorphism}","page":"Graded Vector Spaces","title":"Hecke.cokernel","text":"function cokernel(f::GVSMorphism)\n\nReturn the graded vector space cokernel of f.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#Hecke.decompose-Tuple{GVSObject}","page":"Graded Vector Spaces","title":"Hecke.decompose","text":"function decompose(V::GVSObject)\n\nReturn a vector with the simple objects together with their multiplicities VXi.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#Hecke.dual-Tuple{GVSObject}","page":"Graded Vector Spaces","title":"Hecke.dual","text":"function dual(V::GVSObject)\n\nReturn the graded dual vector space of V.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#Hecke.id-Tuple{VectorSpaceObject}","page":"Graded Vector Spaces","title":"Hecke.id","text":"id(X::VectorSpaceObject{T}) where T\n\nReturn the identity on the vector space X.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#Hecke.tensor_product-Tuple{GVSObject, GVSObject}","page":"Graded Vector Spaces","title":"Hecke.tensor_product","text":"function tensor_product(V::GVSObject, W::GVSObject)\n\nReturn the tensor product VW.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#Hecke.tensor_product-Tuple{VectorSpaceMorphism, VectorSpaceMorphism}","page":"Graded Vector Spaces","title":"Hecke.tensor_product","text":"tensor_product(f::VectorSpaceMorphism, g::VectorSpaceMorphism)\n\nReturn the tensor product of vector space morphisms.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#Hecke.tensor_product-Tuple{VectorSpaceObject, VectorSpaceObject}","page":"Graded Vector Spaces","title":"Hecke.tensor_product","text":"tensor_product(X::VectorSpaceObject{T}, Y::VectorSpaceObject{T}) where {T,S1,S2}\n\nReturn the tensor product of vector spaces.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#Oscar.morphism-Tuple{MatElem}","page":"Graded Vector Spaces","title":"Oscar.morphism","text":"morphism(m::MatElem)\n\nVector space morphisms defined by m.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#TensorCategories.Hom-Tuple{GVSObject, GVSObject}","page":"Graded Vector Spaces","title":"TensorCategories.Hom","text":"function Hom(V::GVSObject, W::GVSObject)\n\nReturn the space of morphisms between graded vector spaces V and W.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#TensorCategories.Hom-Tuple{VectorSpaceObject, VectorSpaceObject}","page":"Graded Vector Spaces","title":"TensorCategories.Hom","text":"Hom(X::VectorSpaceObject, Y::VectorSpaceObject)\n\nReturn the Hom(XY`) as a vector space.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#TensorCategories.associator-Tuple{GVSObject, GVSObject, GVSObject}","page":"Graded Vector Spaces","title":"TensorCategories.associator","text":"function associator(U::GVSObject, V::GVSObject, W::GVSObject)\n\nreturn the associator isomorphism (UV)W  U(VW).\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#TensorCategories.associator-Tuple{VectorSpaceObject, VectorSpaceObject, VectorSpaceObject}","page":"Graded Vector Spaces","title":"TensorCategories.associator","text":"associator(X::VectorSpaceObject, Y::VectorSpaceObject, Z::VectorSpaceObject)\n\nReturn the associator isomorphism a::(X⊗Y)⊗Z -> X⊗(Y⊗Z).\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#TensorCategories.ev-Tuple{GVSObject}","page":"Graded Vector Spaces","title":"TensorCategories.ev","text":"function ev(V::GVSObject)\n\nReturn the evaluation map V*V  𝟙.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#TensorCategories.graded_vector_spaces-Tuple{Field, AbstractAlgebra.Group}","page":"Graded Vector Spaces","title":"TensorCategories.graded_vector_spaces","text":"graded_vector_spaces(F::Field, G::Group)\n\nThe category of G-graded vector spaces.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/VectorSpaces/#TensorCategories.simples-Tuple{GradedVectorSpaces}","page":"Graded Vector Spaces","title":"TensorCategories.simples","text":"function simples(C::GradedVectorSpaces)\n\nReturn a vector containing the simple objects of C.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Centralizer/","page":"The Drinfeld Centralizer","title":"The Drinfeld Centralizer","text":"using TensorCategories, Oscar","category":"page"},{"location":"Constructions/Centralizer/#centralizer","page":"The Drinfeld Centralizer","title":"The Centralizer Construction","text":"","category":"section"},{"location":"Constructions/Centralizer/","page":"The Drinfeld Centralizer","title":"The Drinfeld Centralizer","text":"Let mathcal C be a tensor category and mathcal D subset mathcal C a full topologizing subcategory. Then the centralizer mathcal Z(mathcal C colon mathcal D) is given by tuples (Zgamma) where gamma_(X)colon Zotimes X to X otimes Z mid X in mathcal D satisfies the hexagon equations.","category":"page"},{"location":"Constructions/Centralizer/#Example","page":"The Drinfeld Centralizer","title":"Example","text":"","category":"section"},{"location":"Constructions/Centralizer/","page":"The Drinfeld Centralizer","title":"The Drinfeld Centralizer","text":"Let G = S_3. We want to compute the centralizer of langle delta_(12)rangle.","category":"page"},{"location":"Constructions/Centralizer/","page":"The Drinfeld Centralizer","title":"The Drinfeld Centralizer","text":"G = symmetric_group(3)\n\nVec = graded_vector_spaces(QQ,G)\n\nC = centralizer(Vec, Vec[2])\n\nsimples(C)","category":"page"},{"location":"Constructions/Center/","page":"The Drinfeld Center","title":"The Drinfeld Center","text":"using TensorCategories","category":"page"},{"location":"Constructions/Center/#center","page":"The Drinfeld Center","title":"The Center Construction","text":"","category":"section"},{"location":"Constructions/Center/","page":"The Drinfeld Center","title":"The Drinfeld Center","text":"Let mathcal C be a monoidal category. The Drinfeld center of mathcal C is a category whose objects are tuples (Xgamma) such that X in mathcal C and gamma_Z colon X otimes Z to Z otimes X mid Z in mathcal C is a natural isomorphism such that","category":"page"},{"location":"Constructions/Center/","page":"The Drinfeld Center","title":"The Drinfeld Center","text":"<img src=\"https://i.upmath.me/svg/%5Cbegin%7Btikzcd%7D%0A%09%26%20(Y%20%5Cotimes%20X)%20%5Cotimes%20Z%20%5Car%5Br%2C%20%22a_%7BY%2CX%2CZ%7D%22%5D%20%26%20Y%20%5Cotimes%20(X%20%5Cotimes%20Z)%20%5Car%5Bdr%2C%20%22%5Cid_Y%20%5Cotimes%20%5Cgamma_X(Z)%22%5D%20%26%20%5C%5C%0A%20%20%20%20%20%20%20%20(X%20%5Cotimes%20Y)%20%5Cotimes%20Z%20%5Car%5Bur%2C%20%22%5Cgamma_X(Y)%20%5Cotimes%20%5Cid_Z%22%5D%20%5Car%5Bdr%2C%20%22a_%7BX%2CY%2CZ%7D%22%5D%20%26%20%26%20%26%20Y%20%5Cotimes%20(Z%20%5Cotimes%20X)%20%5C%5C%0A%20%20%20%20%20%20%20%20%20%20%20%20%26%20X%20%5Cotimes%20(Y%20%5Cotimes%20Z)%20%5Car%5Br%2C%20%22%5Cgamma_X(Y%20%5Cotimes%20Z)%22%5D%20%26%20(Y%20%5Cotimes%20Z)%20%5Cotimes%20X%20%5Car%5Bur%2C%20%22a_%7BY%2CZ%2CX%7D%22%5D%20%20%26%0A%5Cend%7Btikzcd%7D\" alt=\"\\begin{tikzcd}\n\t&amp; (Y \\otimes X) \\otimes Z \\ar[r, &quot;a_{Y,X,Z}&quot;] &amp; Y \\otimes (X \\otimes Z) \\ar[dr, &quot;\\id_Y \\otimes \\gamma_X(Z)&quot;] &amp; \\\\\n        (X \\otimes Y) \\otimes Z \\ar[ur, &quot;\\gamma_X(Y) \\otimes \\id_Z&quot;] \\ar[dr, &quot;a_{X,Y,Z}&quot;] &amp; &amp; &amp; Y \\otimes (Z \\otimes X) \\\\\n            &amp; X \\otimes (Y \\otimes Z) \\ar[r, &quot;\\gamma_X(Y \\otimes Z)&quot;] &amp; (Y \\otimes Z) \\otimes X \\ar[ur, &quot;a_{Y,Z,X}&quot;]  &amp;\n\\end{tikzcd}\" /></p>","category":"page"},{"location":"Constructions/Center/","page":"The Drinfeld Center","title":"The Drinfeld Center","text":"commutes for all YZ in mathcal C and gamma_mathbb 1 = mathrmid_X.","category":"page"},{"location":"Constructions/Center/#Computing-the-Center","page":"The Drinfeld Center","title":"Computing the Center","text":"","category":"section"},{"location":"Constructions/Center/","page":"The Drinfeld Center","title":"The Drinfeld Center","text":"The Drinfeld center can be computed explicitely for reasonably small fusion categories using the algorithm described in [5]. Any fusion category implementing the corresponding  interface is supported. ","category":"page"},{"location":"Constructions/Center/#Example","page":"The Drinfeld Center","title":"Example","text":"","category":"section"},{"location":"Constructions/Center/","page":"The Drinfeld Center","title":"The Drinfeld Center","text":"I = Ising()\nC = center(I)\nsimples(C)","category":"page"},{"location":"Constructions/Center/#Methods","page":"The Drinfeld Center","title":"Methods","text":"","category":"section"},{"location":"Constructions/Center/","page":"The Drinfeld Center","title":"The Drinfeld Center","text":"Modules = [TensorCategories]\nPages = [\"Center.jl\", \"CenterChecks.jl\", \"Induction.jl\"]","category":"page"},{"location":"Constructions/Center/#AbstractAlgebra.Generic.dim-Tuple{CenterObject}","page":"The Drinfeld Center","title":"AbstractAlgebra.Generic.dim","text":"dim(X::CenterObject)\n\nReturn the categorical dimension of X.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#AbstractAlgebra.compose-Tuple{CenterMorphism, CenterMorphism}","page":"The Drinfeld Center","title":"AbstractAlgebra.compose","text":"compose(f::CenterMorphism, g::CenterMorphism)\n\nReturn the composition g∘f.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#AbstractAlgebra.direct_sum-Tuple{CenterMorphism, CenterMorphism}","page":"The Drinfeld Center","title":"AbstractAlgebra.direct_sum","text":"direct_sum(f::CenterMorphism, g::CenterMorphism)\n\nReturn the direct sum of f and g.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#AbstractAlgebra.direct_sum-Tuple{CenterObject, CenterObject}","page":"The Drinfeld Center","title":"AbstractAlgebra.direct_sum","text":"direct_sum(X::CenterObject, Y::CenterObject)\n\nReturn the direct sum object of X and Y.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#AbstractAlgebra.is_isomorphic-Tuple{CenterObject, CenterObject}","page":"The Drinfeld Center","title":"AbstractAlgebra.is_isomorphic","text":"is_isomorphic(X::CenterObject, Y::CenterObject)\n\nCheck if X≃Y. Return (true, m) where mis an isomorphism if true, else return (false,nothing).\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#AbstractAlgebra.kernel-Tuple{CenterMorphism}","page":"The Drinfeld Center","title":"AbstractAlgebra.kernel","text":"kernel(f::CenterMoprhism)\n\nReturn a tuple (K,k) where Kis the kernel object and kis the inclusion.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#Base.inv-Tuple{CenterMorphism}","page":"The Drinfeld Center","title":"Base.inv","text":"inv(f::CenterMorphism)\n\nReturn the inverse of fif possible.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#Base.one-Tuple{CenterCategory}","page":"The Drinfeld Center","title":"Base.one","text":"one(C::CenterCategory)\n\nReturn the one object of C.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#Base.zero-Tuple{CenterCategory}","page":"The Drinfeld Center","title":"Base.zero","text":"zero(C::CenterCategory)\n\nReturn the zero object of C.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#Hecke.center-Tuple{Category}","page":"The Drinfeld Center","title":"Hecke.center","text":"center(C::Category)\n\nReturn the Drinfeld center of C.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#Hecke.cokernel-Tuple{CenterMorphism}","page":"The Drinfeld Center","title":"Hecke.cokernel","text":"cokernel(f::CenterMorphism)\n\nReturn a tuple (C,c) where Cis the cokernel object and cis the projection.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#Hecke.dual-Tuple{CenterObject}","page":"The Drinfeld Center","title":"Hecke.dual","text":"dual(X::CenterObject)\n\nReturn the (left) dual object of X.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#Hecke.id-Tuple{CenterObject}","page":"The Drinfeld Center","title":"Hecke.id","text":"id(X::CenterObject)\n\nReturn the identity on X.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#Hecke.is_central","page":"The Drinfeld Center","title":"Hecke.is_central","text":"is_central(Z::Object)\n\nReturn true if Z is in the categorical center, i.e. there exists a half-braiding on Z.\n\n\n\n\n\n","category":"function"},{"location":"Constructions/Center/#Hecke.tensor_product-Tuple{CenterMorphism, CenterMorphism}","page":"The Drinfeld Center","title":"Hecke.tensor_product","text":"tensor_product(f::CenterMorphism,g::CenterMorphism)\n\nReturn the tensor product of f and g.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#Hecke.tensor_product-Tuple{CenterObject, CenterObject}","page":"The Drinfeld Center","title":"Hecke.tensor_product","text":"tensor_product(X::CenterObject, Y::CenterObject)\n\nReturn the tensor product of X and Y.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#LinearAlgebra.tr-Tuple{CenterMorphism}","page":"The Drinfeld Center","title":"LinearAlgebra.tr","text":"tr(f:::CenterMorphism)\n\nReturn the categorical trace of f.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#Oscar.morphism-Tuple{CenterMorphism}","page":"The Drinfeld Center","title":"Oscar.morphism","text":"morphism(f::CenterMorphism)\n\nReturn the image under the forgetful functor.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#TensorCategories.add_simple!-Tuple{CenterCategory, CenterObject}","page":"The Drinfeld Center","title":"TensorCategories.add_simple!","text":"add_simple!(C::CenterCategory, S::CenterObject)\n\nAdd the simple object S to the vector of simple objects.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#TensorCategories.associator-Tuple{CenterObject, CenterObject, CenterObject}","page":"The Drinfeld Center","title":"TensorCategories.associator","text":"associator(X::CenterObject, Y::CenterObject, Z::CenterObject)\n\nReturn the associator isomorphism (X⊗Y)⊗Z → X⊗(Y⊗Z).\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#TensorCategories.braiding-Tuple{CenterObject, CenterObject}","page":"The Drinfeld Center","title":"TensorCategories.braiding","text":"braiding(X::CenterObject, Y::CenterObject)\n\nReturn the braiding isomorphism γ_X(Y): X⊗Y → Y⊗X.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#TensorCategories.central_projection","page":"The Drinfeld Center","title":"TensorCategories.central_projection","text":"central_projection(X::CenterObject, Y::CenterObject, f::Morphism)\n\nCompute the image under the projection Hom(F(X),F(Y)) → Hom(X,Y).\n\n\n\n\n\n","category":"function"},{"location":"Constructions/Center/#TensorCategories.coev-Tuple{CenterObject}","page":"The Drinfeld Center","title":"TensorCategories.coev","text":"coev(X::CenterObject)\n\nReturn the coevaluation morphism 1 → X⊗X∗.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#TensorCategories.ev-Tuple{CenterObject}","page":"The Drinfeld Center","title":"TensorCategories.ev","text":"ev(X::CenterObject)\n\nReturn the evaluation morphism X⊗X → 1.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#TensorCategories.fpdim-Tuple{CenterObject}","page":"The Drinfeld Center","title":"TensorCategories.fpdim","text":"fpdim(X::CenterObject)\n\nReturn the Frobenius-Perron dimension of X.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#TensorCategories.half_braiding-Tuple{CenterObject, Object}","page":"The Drinfeld Center","title":"TensorCategories.half_braiding","text":"half_braiding(X::CenterObject, Y::Object)\n\nReturn the half braiding isomorphism γ_X(Y): X⊗Y → Y⊗X.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#TensorCategories.half_braiding-Tuple{CenterObject}","page":"The Drinfeld Center","title":"TensorCategories.half_braiding","text":"half_braiding(Z::CenterObject)\n\nReturn  a vector with half braiding morphisms Z⊗S → S⊗Z for all simple objects S.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#TensorCategories.half_braidings-Tuple{Object}","page":"The Drinfeld Center","title":"TensorCategories.half_braidings","text":"half_braidings(Z::Object)\n\nReturn all objects in the center lying over Z.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#TensorCategories.object-Tuple{CenterObject}","page":"The Drinfeld Center","title":"TensorCategories.object","text":"object(X::CenterObject)\n\nReturn the image under the forgetful functor.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#TensorCategories.simples-Tuple{CenterCategory}","page":"The Drinfeld Center","title":"TensorCategories.simples","text":"simples(C::CenterCategory)\n\nReturn a vector containing the simple objects of C. \n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#TensorCategories.spherical-Tuple{CenterObject}","page":"The Drinfeld Center","title":"TensorCategories.spherical","text":"spherical(X::CenterObject)\n\nReturn the spherical structure X → X∗∗ of X.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#TensorCategories.zero_morphism-Tuple{CenterObject, CenterObject}","page":"The Drinfeld Center","title":"TensorCategories.zero_morphism","text":"zero_morphism(X::CenterObject, Y::CenterObject)\n\nReturn the zero morphism 0:X → Y.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#TensorCategories.is_half_braiding","page":"The Drinfeld Center","title":"TensorCategories.is_half_braiding","text":"is_half_braiding(X::Object, half_braiding::Vector{<:Morphism})\n\nTBW\n\n\n\n\n\n","category":"function"},{"location":"Constructions/Center/#TensorCategories.adjusted_dual_basis-Tuple{AbstractHomSpace, AbstractHomSpace, Object, Object, Object}","page":"The Drinfeld Center","title":"TensorCategories.adjusted_dual_basis","text":"adjusted_dual_basis(V::AbstractHomSpace, U::AbstractHomSpace, S::Object, W::Object, T::Object)\n\nCompute a dual basis for the spaces Hom(S, W⊗T) and Hom(S̄⊗W, T̄)\n\n\n\n\n\n","category":"method"},{"location":"Constructions/Center/#TensorCategories.dual_basis-Tuple{AbstractHomSpace, AbstractHomSpace}","page":"The Drinfeld Center","title":"TensorCategories.dual_basis","text":"dual_basis(V::AbstractHomSpace, W::AbstractHomSpace)\n\nCompute the dual basis for Hom(X,Y) and Hom(X̄,Ȳ)\n\n\n\n\n\n","category":"method"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"using TensorCategories, Oscar","category":"page"},{"location":"Interface/Categories/#Basics","page":"Categories","title":"Basics","text":"","category":"section"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"The Interface is naturally based on three abstract types which  have to be extended:","category":"page"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"abstract type Category end\nabstract type Object end\nabstract type Morphism end","category":"page"},{"location":"Interface/Categories/#Categories","page":"Categories","title":"Categories","text":"","category":"section"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"Categories without any additional structure do not need any  fields or methods. We follow the example of the category of finite sets.","category":"page"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"struct FinSets <: Category end","category":"page"},{"location":"Interface/Categories/#Objects","page":"Categories","title":"Objects","text":"","category":"section"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"Objects need at least one field parent for the parent category or a method parentreturning the respective category. Any other information needed to work with the objects is arbitrary.","category":"page"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"struct FinSetObject <: Object\n    parent::FinSets\n    set::Set\nend","category":"page"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"Here we wrap a set to an object.","category":"page"},{"location":"Interface/Categories/#Morphisms","page":"Categories","title":"Morphisms","text":"","category":"section"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"Morphisms need to provide fields","category":"page"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"domain\ncodomain","category":"page"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"or methods","category":"page"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"domain\ncodomain","category":"page"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"For the category of sets we get","category":"page"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"struct FinSetMorphism <: Morphism\n    domain::FinSetObject\n    codomain::FinSetObject\n    map\nend","category":"page"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"Where one now can design any coding for a morphism of sets that fit the desired purpose.","category":"page"},{"location":"Interface/Categories/#Required-Methods","page":"Categories","title":"Required Methods","text":"","category":"section"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"Necessary methods to implemented for morphisms, objects and categories are","category":"page"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"compose(f::YourMorphism, g::YourMorphism)::YourMorphism returning the composition g circ f.\nid(X::YourObject)::YourMorphism returning the identity morphism on X.\nHom(X::YourObject, Y::YourObject)::AbstractHomSet constructing an object <:AbstractHomSet.","category":"page"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"Here anything extending AbstractHomspace needs to provide the fields ","category":"page"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"domain\ncodomain","category":"page"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"or methods","category":"page"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"domain\ncodomain.","category":"page"},{"location":"Interface/Categories/#Additional-methods","page":"Categories","title":"Additional methods","text":"","category":"section"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"Your category might have more structure. For categories which are ","category":"page"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"abelian\nmonoidal\ntensor","category":"page"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"visit the corresponding chapter. The interface supports additionally the following constructions and operations.","category":"page"},{"location":"Interface/Categories/#(Co)Products","page":"Categories","title":"(Co)Products","text":"","category":"section"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"For a list of objects X_1X_n methods for the product shall return an object representing the categorical product prod X_i together with the projection maps p_i colon prod X_i to X_i. ","category":"page"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"product(X::YourObject...)::Tuple{YourObject, Vector{YourMorphism}}","category":"page"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"You may only implement a binary version product(X,Y) in which case TensorCategories extends it automatically to a list-version. Keep in mind that this might be devastating to the runtime, since iteratively applying a binary product involves composing morphisms which most likely is expensive.","category":"page"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"TensorCategories will also generate an infix operator ","category":"page"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"×(X::YourObject, Y::YourObject)::YourObject","category":"page"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"that only returns the object in question.","category":"page"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"Dually the same applies for a coproduct  Xᵢ.","category":"page"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"coproduct(X::YourObject...)::Tuple{YourObject, Vector{YourMorphism}}","category":"page"},{"location":"Interface/Categories/#Initial-and-Terminal-Objects","page":"Categories","title":"Initial and Terminal Objects","text":"","category":"section"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"If a category has an initial and/or terminal object one can provide those.","category":"page"},{"location":"Interface/Categories/","page":"Categories","title":"Categories","text":"initial_object(::Category)::Object\nterminal_object(::Category)::Object","category":"page"},{"location":"Interface/MonoidalCategories/#Monoidal-Categories","page":"Monoidal Categories","title":"Monoidal Categories","text":"","category":"section"},{"location":"Interface/MonoidalCategories/","page":"Monoidal Categories","title":"Monoidal Categories","text":"A monoidal category is a quintuplet (mathcal C otimes mathbb 1 a iota) where ","category":"page"},{"location":"Interface/MonoidalCategories/","page":"Monoidal Categories","title":"Monoidal Categories","text":"mathcal C is a category\notimescolon mathcal C times mathcal C to mathcal Cis a bifunctor\na_XYZ colon (X otimes Y) otimes Z to X otimes (Y otimes Z) is a natural transformation\niota colon mathbb 1 otimes mathbb 1 to mathbb 1 is an isomorphism","category":"page"},{"location":"Interface/MonoidalCategories/","page":"Monoidal Categories","title":"Monoidal Categories","text":"such that ","category":"page"},{"location":"Interface/MonoidalCategories/","page":"Monoidal Categories","title":"Monoidal Categories","text":"<img src=\"https://i.upmath.me/svg/%5Cbegin%7Btikzcd%7D%0A%09%26%20%7B((W%20%5Cotimes%20X)%20%5Cotimes%20Y)%5Cotimes%20Z%7D%20%5C%5C%0A%09%7B(W%20%5Cotimes%20(X%20%5Cotimes%20Y))%20%5Cotimes%20Z%7D%20%26%26%20%7B(W%20%5Cotimes%20X)%20%5Cotimes%20(Y%5Cotimes%20Z)%7D%20%5C%5C%0A%09%7BW%20%5Cotimes%20((X%5Cotimes%20Y)%20%5Cotimes%20Z)%7D%20%26%26%20%7BW%20%5Cotimes%20(X%20%5Cotimes%20(Y%5Cotimes%20Z))%7D%0A%09%5Carrow%5B%22%7Ba_%7BW%2CX%2CY%7D%20%5Cotimes%20%5Cmathrm%7Bid%7D_Z%7D%22'%7Bpos%3D1%7D%2C%20shorten%20%3C%3D4pt%2C%20from%3D1-2%2C%20to%3D2-1%5D%0A%09%5Carrow%5B%22%7Ba_%7BW%2CX%5Cotimes%20Y%2CZ%7D%7D%22'%2C%20shift%20right%3D5%2C%20draw%3Dnone%2C%20from%3D2-1%2C%20to%3D3-1%5D%0A%09%5Carrow%5Bfrom%3D2-1%2C%20to%3D3-1%5D%0A%09%5Carrow%5B%22%7B%5Cmathrm%7Bid%7D%5Cotimes%20a_%7BX%2CY%2CZ%7D%7D%22'%2C%20from%3D3-1%2C%20to%3D3-3%5D%0A%09%5Carrow%5B%22%7Ba_%7BW%5Cotimes%20X%2C%20Y%2CZ%7D%7D%22%7Bpos%3D0.8%7D%2C%20from%3D1-2%2C%20to%3D2-3%5D%0A%09%5Carrow%5B%22%7Ba_%7BW%2CX%2CY%5Cotimes%20Z%7D%7D%22%2C%20shift%20left%3D5%2C%20draw%3Dnone%2C%20from%3D2-3%2C%20to%3D3-3%5D%0A%09%5Carrow%5Bfrom%3D2-3%2C%20to%3D3-3%5D%0A%5Cend%7Btikzcd%7D\" alt=\"\\begin{tikzcd}\n\t&amp; {((W \\otimes X) \\otimes Y)\\otimes Z} \\\\\n\t{(W \\otimes (X \\otimes Y)) \\otimes Z} &amp;&amp; {(W \\otimes X) \\otimes (Y\\otimes Z)} \\\\\n\t{W \\otimes ((X\\otimes Y) \\otimes Z)} &amp;&amp; {W \\otimes (X \\otimes (Y\\otimes Z))}\n\t\\arrow[&quot;{a_{W,X,Y} \\otimes \\mathrm{id}_Z}&quot;'{pos=1}, shorten &lt;=4pt, from=1-2, to=2-1]\n\t\\arrow[&quot;{a_{W,X\\otimes Y,Z}}&quot;', shift right=5, draw=none, from=2-1, to=3-1]\n\t\\arrow[from=2-1, to=3-1]\n\t\\arrow[&quot;{\\mathrm{id}\\otimes a_{X,Y,Z}}&quot;', from=3-1, to=3-3]\n\t\\arrow[&quot;{a_{W\\otimes X, Y,Z}}&quot;{pos=0.8}, from=1-2, to=2-3]\n\t\\arrow[&quot;{a_{W,X,Y\\otimes Z}}&quot;, shift left=5, draw=none, from=2-3, to=3-3]\n\t\\arrow[from=2-3, to=3-3]\n\\end{tikzcd}\" />","category":"page"},{"location":"Interface/MonoidalCategories/","page":"Monoidal Categories","title":"Monoidal Categories","text":"commutes for all objects WXYZ in mathcal C and","category":"page"},{"location":"Interface/MonoidalCategories/","page":"Monoidal Categories","title":"Monoidal Categories","text":"beginalign*\n\tL_mathbb 1 colon  X to mathbb 1 otimes X \n\tR_mathbb 1 colon  X to X otimes mathbb 1\nendalign*","category":"page"},{"location":"Interface/MonoidalCategories/","page":"Monoidal Categories","title":"Monoidal Categories","text":"are autoequivalences.","category":"page"},{"location":"Interface/MonoidalCategories/#Conventions-and-Restrictions","page":"Monoidal Categories","title":"Conventions and Restrictions","text":"","category":"section"},{"location":"Interface/MonoidalCategories/","page":"Monoidal Categories","title":"Monoidal Categories","text":"At the current state all monoidal categories are assumed to satisfy X otimes mathbb 1 cong X cong mathbb 1 otimes X and iota = mathrmid_mathbb 1.","category":"page"},{"location":"Interface/MonoidalCategories/","page":"Monoidal Categories","title":"Monoidal Categories","text":"But building non-strict monoidal categories is explicitly encouraged, as this support is a strength of our Package. ","category":"page"},{"location":"Interface/MonoidalCategories/#Monoidal-Categories-2","page":"Monoidal Categories","title":"Monoidal Categories","text":"","category":"section"},{"location":"Interface/MonoidalCategories/","page":"Monoidal Categories","title":"Monoidal Categories","text":"Following the definition we need the following methods.","category":"page"},{"location":"Interface/MonoidalCategories/","page":"Monoidal Categories","title":"Monoidal Categories","text":"tensor_product(X::YourObject...)::YourObject returning the monoidal product. You can access your method by invoking the infix operate ⊗.\ntensor_product(f::YourMorphism...)::YourMorphism returning the the monoidal product of morphisms. You can access your method by invoking the infix operate ⊗.\none(C::YourCategory)::YourObject returning the monoidal unit.\nassociator(X::YourObject, Y::YourObject, Z::YourObject).","category":"page"},{"location":"Interface/MonoidalCategories/#Rigidity","page":"Monoidal Categories","title":"Rigidity","text":"","category":"section"},{"location":"Interface/MonoidalCategories/","page":"Monoidal Categories","title":"Monoidal Categories","text":"Whenever there are objects which admit duals it is feasible to acces them.","category":"page"},{"location":"Interface/MonoidalCategories/","page":"Monoidal Categories","title":"Monoidal Categories","text":"left_dual(X::YourObject)::YourObject return the left dual X^ast.\nright_dual(X::YourObject)::YourObject return the right dual ^ast X.\nev(X::YourObject)::YourMorphism return the evaluation morphism mathrmev_Xcolon X^ast otimes X to mathbb 1.\ncoev(X::YourObject)::YourMorphism return the coevaluation morphism mathrmcoev_Xcolon mathbb 1 to Xotimes X^ast. ","category":"page"},{"location":"Interface/MonoidalCategories/","page":"Monoidal Categories","title":"Monoidal Categories","text":"This allows to generically compute ","category":"page"},{"location":"Interface/MonoidalCategories/","page":"Monoidal Categories","title":"Monoidal Categories","text":"left_dual(::Morphism)","category":"page"},{"location":"Interface/MonoidalCategories/#TensorCategories.left_dual-Tuple{Morphism}","page":"Monoidal Categories","title":"TensorCategories.left_dual","text":"left_dual(f::Morphism)\n\nReturn the left dual of a morphism f.\n\n\n\n\n\n","category":"method"},{"location":"Interface/MonoidalCategories/","page":"Monoidal Categories","title":"Monoidal Categories","text":"Note that dual will always call left_dual.","category":"page"},{"location":"Interface/MonoidalCategories/#Checks","page":"Monoidal Categories","title":"Checks","text":"","category":"section"},{"location":"Interface/MonoidalCategories/","page":"Monoidal Categories","title":"Monoidal Categories","text":"To verify for oneself the pentagon and hexagon axioms can be checked.","category":"page"},{"location":"Interface/MonoidalCategories/","page":"Monoidal Categories","title":"Monoidal Categories","text":"pentagon_axiom\nhexagon_axiom","category":"page"},{"location":"Interface/MonoidalCategories/#TensorCategories.pentagon_axiom","page":"Monoidal Categories","title":"TensorCategories.pentagon_axiom","text":"pentagon_axiom(X::T, Y::T, Z::T, W::T) where T <: Object\n\nCheck the pentagon axiom for X, Y, Z, W.\n\n\n\n\n\npentagon_axiom(objects::Vector{<:Object}, log::Bool = false)\n\nCheck the pentagon axiom for all combinations of objects in objects. If log = true an array with the failing combinations is returned\n\n\n\n\n\npentagon_axiom(C::Category, log::Bool = false)\n\nCheck the pentagon axiom for all combinations of  simple objects of C. If  log = true an array with the failing combinations is returned\n\n\n\n\n\n","category":"function"},{"location":"Interface/MonoidalCategories/#TensorCategories.hexagon_axiom","page":"Monoidal Categories","title":"TensorCategories.hexagon_axiom","text":"hexagon_axiom(X::T, Y::T, Z::T) where T <: Object\n\nCheck the hexagon axiom for X, Y, Z.\n\n\n\n\n\nhexagon_axiom(objects::Vector{<:Object}, log::Bool = false)\n\nCheck the hexagon axiom for all combinations of objects in objects. If log = true an array with the failing combinations is returned\n\n\n\n\n\nhexagon_axiom(C::Category, log::Bool = false)\n\nCheck the hexagon axiom for all combinations of  simple objects of C. If  log = true an array with the failing combinations is returned\n\n\n\n\n\n","category":"function"},{"location":"SixJCategories/6JExamples/#Tambara-Yamagami-Categories","page":"Fusion Categories with 6j-Symbols","title":"Tambara Yamagami Categories","text":"","category":"section"},{"location":"SixJCategories/6JExamples/","page":"Fusion Categories with 6j-Symbols","title":"Fusion Categories with 6j-Symbols","text":"Tambara and Yamagami classified a class of near-group categories of multiplicity one over algebraically closed fields in [2]. Let A be an abelian group. Choose a square root tau in k of vert Avert and a non-degenerate symmetric bilinear form chi colon A times A to k^times. Then the Tambara-Yamagimi category TY(Achitau) has objects A cup m with fusion rules ","category":"page"},{"location":"SixJCategories/6JExamples/","page":"Fusion Categories with 6j-Symbols","title":"Fusion Categories with 6j-Symbols","text":"beginalign*\n    a  b = a+ba otimes m = m otimes a = m m otimes m = sumlimits_a in G a\nendalign*","category":"page"},{"location":"SixJCategories/6JExamples/","page":"Fusion Categories with 6j-Symbols","title":"Fusion Categories with 6j-Symbols","text":"for ab in G. The non-trivial associativity constraints are given by ","category":"page"},{"location":"SixJCategories/6JExamples/","page":"Fusion Categories with 6j-Symbols","title":"Fusion Categories with 6j-Symbols","text":"beginalign*\n    a_amb = chi(ab)mathrmid_m  a_mam = bigopluslimits_bin Achi(ab)mathrmid_b  a_mmm = bigopluslimits_ab in A frac1tauchi(ab)mathrmid_m\nendalign*","category":"page"},{"location":"SixJCategories/6JExamples/","page":"Fusion Categories with 6j-Symbols","title":"Fusion Categories with 6j-Symbols","text":"Those categories can be constructed with a generic symmetric bilinear form or with a custom bilinear form and over arbitrary fields.","category":"page"},{"location":"SixJCategories/6JExamples/","page":"Fusion Categories with 6j-Symbols","title":"Fusion Categories with 6j-Symbols","text":"tambara_yamagami","category":"page"},{"location":"SixJCategories/6JExamples/#TensorCategories.tambara_yamagami","page":"Fusion Categories with 6j-Symbols","title":"TensorCategories.tambara_yamagami","text":"tambara_yamagami(A::Group)\n\nConstruct TY(Aτχ) over ℚ̅ where τ = A and χ is a generic non-degenerate bilinear form.  \n\n\n\n\n\ntambara_yamagami(K::ring, A::Group)\n\nConstruct TY(Aτχ) over K where τ = A and χ is a generic non-degenerate bilinear form.  \n\n\n\n\n\ntambara_yamagami(K::Ring, A::Group, τ::RingElem)\n\nConstruct TY(Aτχ) over K where χ is a generic non-degenerate bilinear form.  \n\n\n\n\n\ntambara_yamagami(K::Ring, A::Group, τ::RingElem)\n\nConstruct TY(Aτχ) over K where τ = A.  \n\n\n\n\n\ntambara_yamagami(K::Ring, A::Group, τ::RingElem, χ::BilinearForm)\n\nConstruct the Category TY(Aτχ). \n\n\n\n\n\n","category":"function"},{"location":"SixJCategories/6JExamples/","page":"Fusion Categories with 6j-Symbols","title":"Fusion Categories with 6j-Symbols","text":"Tambara-Yamagami categories are implemented as an instance of SixJCategory and hence all functionality follows from there.","category":"page"},{"location":"SixJCategories/6JExamples/#Ising-Category","page":"Fusion Categories with 6j-Symbols","title":"Ising Category","text":"","category":"section"},{"location":"SixJCategories/6JExamples/","page":"Fusion Categories with 6j-Symbols","title":"Fusion Categories with 6j-Symbols","text":"The Ising fusion category is a special example of a Tambara-Yamagami category with A = mathbb Z_2.  ","category":"page"},{"location":"SixJCategories/6JExamples/","page":"Fusion Categories with 6j-Symbols","title":"Fusion Categories with 6j-Symbols","text":"Ising","category":"page"},{"location":"SixJCategories/6JExamples/#TensorCategories.Ising","page":"Fusion Categories with 6j-Symbols","title":"TensorCategories.Ising","text":"Ising()\n\nConstruct the Ising category over ℚ(2).\n\n\n\n\n\nIsing(F::Ring)\n\nConstruct the Ising category over F.\n\n\n\n\n\nIsing(F::Ring, τ::RingElem)\n\nConstruct the Ising category with specific τ = 2.\n\n\n\n\n\nIsing(F::Ring, q::Int)\n\nConstruct the braided Ising category over F where q = ±1 defined the braiding defined by ±i. \n\n\n\n\n\nIsing(F::Ring, τ::RingElem, q::Int)\n\nConstruct the Ising fusion category where τ = 2 a root and q ∈ {1,-1} specifies the braiding if it exists.\n\n\n\n\n\n","category":"function"},{"location":"SixJCategories/6JExamples/#The-Haagerup-Subfactor","page":"Fusion Categories with 6j-Symbols","title":"The Haagerup Subfactor","text":"","category":"section"},{"location":"SixJCategories/6JExamples/","page":"Fusion Categories with 6j-Symbols","title":"Fusion Categories with 6j-Symbols","text":"The fusion categories stemming from the Haagerup subfactor are a well known and important example of a fusion category. Details can be found in  [3].","category":"page"},{"location":"SixJCategories/6JExamples/","page":"Fusion Categories with 6j-Symbols","title":"Fusion Categories with 6j-Symbols","text":"In the Morita equivalence class of the Haagerup subfactor lie three categories. We call them mathcal H_1mathcal H_2 and mathcal H_3. The first two have multiplicity larger then 1 and are up to now not included. The third has multiplicity 1 and is also known as the Haagerup-Izumi category for mathbb Z_3. It has six simple objects and fusion rules","category":"page"},{"location":"SixJCategories/6JExamples/","page":"Fusion Categories with 6j-Symbols","title":"Fusion Categories with 6j-Symbols","text":"beginarrayccccccc\n         mathbb 1  alpha  alpha^ast  rho  _alpharho  _alpha^astrho  hline hline\n        mathbb 1  mathbb 1  alpha  alpha^ast  rho  _alpharho  _alpha^astrho  hline\n        alpha  alpha  alpha^ast  mathbb 1  _alpharho  _alpha^astrho  rho  hline\n        alpha^ast  alpha^ast  mathbb 1  alpha  _alpha^astrho  rho  alpharho  hline\n        rho  rho  _alpha^astrho  _alpharho  mathbb 1 oplus rho oplus _alpharho oplus _alpha^astrho  alpha oplus rho oplus _alpharho oplus _alpha^astrho  alpha^ast oplus rho oplus _alpharho oplus _alpha^astrho  hline \n        _alpharho  _alpharho  _alpha^astrho  rho  alpha oplus rho oplus _alpharho oplus _alpha^astrho  mathbb 1 oplus rho oplus _alpharho oplus _alpha^astrho  alpha^ast  oplus rho oplus _alpharho oplus _alpha^astrho  hline\n        _alpha^astrho  _alpha^astrho  rho  _alpharho  alpha^ast oplus rho oplus _alpharho oplus _alpha^astrho  alpha oplus rho oplus _alpharho oplus _alpha^astrho  mathbb 1 oplus  rho oplus _alpharho oplus _alpha^astrho \n    endarray","category":"page"},{"location":"SixJCategories/6JExamples/","page":"Fusion Categories with 6j-Symbols","title":"Fusion Categories with 6j-Symbols","text":"We implement the category mathcal H_3 as an instance of SixJCategory. The other two will follow as soon as we know the proper 6j-symbols.","category":"page"},{"location":"SixJCategories/6JExamples/","page":"Fusion Categories with 6j-Symbols","title":"Fusion Categories with 6j-Symbols","text":"haagerup_H3","category":"page"},{"location":"SixJCategories/6JExamples/#TensorCategories.haagerup_H3","page":"Fusion Categories with 6j-Symbols","title":"TensorCategories.haagerup_H3","text":"haagerup_H3([p1 = 1, p2 = 2])\n\nBuild the Haagerup ℋ₃ subfactor category. The category is build as SixJCategory. The associators are taken from the paper \n\nhttps://arxiv.org/pdf/1906.01322\n\nwhere p1,p2 = ±1 are parameters for the different possible sets of associators.\n\n\n\n\n\n","category":"function"},{"location":"SixJCategories/6JExamples/#Fusion-Categories-From-Truncated-Hecke-Categories","page":"Fusion Categories with 6j-Symbols","title":"Fusion Categories From Truncated Hecke Categories","text":"","category":"section"},{"location":"SixJCategories/6JExamples/","page":"Fusion Categories with 6j-Symbols","title":"Fusion Categories with 6j-Symbols","text":"TODO: Explanation","category":"page"},{"location":"SixJCategories/6JExamples/","page":"Fusion Categories with 6j-Symbols","title":"Fusion Categories with 6j-Symbols","text":"I2\nI2subcategory","category":"page"},{"location":"SixJCategories/6JExamples/#TensorCategories.I2","page":"Fusion Categories with 6j-Symbols","title":"TensorCategories.I2","text":"I2(m::Int)\nI2(m::Int, K::Ring)\n\nCreates the categorification of biggest cell in I2(m). \n\n\n\n\n\n","category":"function"},{"location":"SixJCategories/6JExamples/#TensorCategories.I2subcategory","page":"Fusion Categories with 6j-Symbols","title":"TensorCategories.I2subcategory","text":"I2subcategory(m::Int)\nI2subcategory(m::Int, R::Ring)\n\nCreates the fusion subcategory of I2.\n\n\n\n\n\n","category":"function"},{"location":"SixJCategories/6JExamples/#Various-Other-Categories-Given-by-6J-Symbols","page":"Fusion Categories with 6j-Symbols","title":"Various Other Categories Given by 6J-Symbols","text":"","category":"section"},{"location":"SixJCategories/6JExamples/","page":"Fusion Categories with 6j-Symbols","title":"Fusion Categories with 6j-Symbols","text":"Here are some more examples to play around. ","category":"page"},{"location":"SixJCategories/6JExamples/#Categorifications-by-Vercleyen-and-Singerland","page":"Fusion Categories with 6j-Symbols","title":"Categorifications by Vercleyen and Singerland","text":"","category":"section"},{"location":"SixJCategories/6JExamples/","page":"Fusion Categories with 6j-Symbols","title":"Fusion Categories with 6j-Symbols","text":"In [4] they found a huge number of fusion rings and some explicit categorifications that are neither Tambara-Yamagami nor Haagerup-Izumi categories. ","category":"page"},{"location":"SixJCategories/6JExamples/#FR{}_2{82}","page":"Fusion Categories with 6j-Symbols","title":"FR_2^82","text":"","category":"section"},{"location":"SixJCategories/6JExamples/","page":"Fusion Categories with 6j-Symbols","title":"Fusion Categories with 6j-Symbols","text":"They provide 97 different (but maybe equivalent) associators one can access.","category":"page"},{"location":"SixJCategories/6JExamples/","page":"Fusion Categories with 6j-Symbols","title":"Fusion Categories with 6j-Symbols","text":"cat_fr_8122","category":"page"},{"location":"SixJCategories/6JExamples/#TensorCategories.cat_fr_8122","page":"Fusion Categories with 6j-Symbols","title":"TensorCategories.cat_fr_8122","text":"cat_fr_8122(n::Int64)\n\nCategorification of fusion ring FR8211. n chooses one of 96 possibily  equivalent sets of associators.\n\n\n\n\n\n","category":"function"},{"location":"SixJCategories/6JExamples/#FR{}_3{94}","page":"Fusion Categories with 6j-Symbols","title":"FR_3^94","text":"","category":"section"},{"location":"SixJCategories/6JExamples/","page":"Fusion Categories with 6j-Symbols","title":"Fusion Categories with 6j-Symbols","text":"We have a singel associator for this ring.","category":"page"},{"location":"SixJCategories/6JExamples/","page":"Fusion Categories with 6j-Symbols","title":"Fusion Categories with 6j-Symbols","text":"cat_fr_9143","category":"page"},{"location":"SixJCategories/6JExamples/#TensorCategories.cat_fr_9143","page":"Fusion Categories with 6j-Symbols","title":"TensorCategories.cat_fr_9143","text":"cat_fr_9143()\n\nCategorification of fusion ring FR9143. \n\n\n\n\n\n","category":"function"},{"location":"Interface/AbelianCategories/#Interface-for-Abelian-Categories","page":"Abelian Categories","title":"Interface for Abelian Categories","text":"","category":"section"},{"location":"Interface/AbelianCategories/","page":"Abelian Categories","title":"Abelian Categories","text":"Abelian categories are all over the place and very important. Thus we provide an Interface for (pre)additive and abelian categories. First recall the definitions:","category":"page"},{"location":"Interface/AbelianCategories/","page":"Abelian Categories","title":"Abelian Categories","text":"A preadditive category is a category mathcal C such that all Hom-spaces are abelian groups and composition is bilinear. As a consequence all finite products are biproducts, also called direct sums. ","category":"page"},{"location":"Interface/AbelianCategories/","page":"Abelian Categories","title":"Abelian Categories","text":"Then mathcal C is called additive if it is preadditive and all finite products exist.","category":"page"},{"location":"Interface/AbelianCategories/#Additivity","page":"Abelian Categories","title":"Additivity","text":"","category":"section"},{"location":"Interface/AbelianCategories/","page":"Abelian Categories","title":"Abelian Categories","text":"To implement the preadditive structure you need the following methods","category":"page"},{"location":"Interface/AbelianCategories/","page":"Abelian Categories","title":"Abelian Categories","text":"direct sum(X::YourObject...)::Tuple{YourObject, Vector{YourMorphism}, Yector{YourMorphism} returning the direct sum object, the inclusions and projections. You might only implement the binary operation while the package will compile a vector version. This might come with performance issues.\n+(f::YourMorphism, g::YourMorphism)::YourMorphism providing the addition on morphisms.\nzero_morphism(X::YourObject, Y::YourObject)::YourMorphism","category":"page"},{"location":"Interface/AbelianCategories/","page":"Abelian Categories","title":"Abelian Categories","text":"To complete additivity there has to be a zero object.","category":"page"},{"location":"Interface/AbelianCategories/","page":"Abelian Categories","title":"Abelian Categories","text":"zero(C::YourCategory)::YourObject","category":"page"},{"location":"Interface/AbelianCategories/#Abelian-Categories","page":"Abelian Categories","title":"Abelian Categories","text":"","category":"section"},{"location":"Interface/AbelianCategories/","page":"Abelian Categories","title":"Abelian Categories","text":"A category is called abelian if ","category":"page"},{"location":"Interface/AbelianCategories/","page":"Abelian Categories","title":"Abelian Categories","text":"it is  additive,\nevery morphism has a kernel and cokernel,\nevery monomorphism and epimorphism is normal.","category":"page"},{"location":"Interface/AbelianCategories/","page":"Abelian Categories","title":"Abelian Categories","text":"We need the following additional methods:","category":"page"},{"location":"Interface/AbelianCategories/","page":"Abelian Categories","title":"Abelian Categories","text":"kernel(f::YourMorphism)::Tuple{YourObject, YourMorphism} providing the kernel tuple (kphi) for f colon X to Y where phi colon k hookrightarrow X is the embedding.\ncokernel(f::YourMorphism)::Tuple{YourObject, YourMorphism} providing the cokernel tuple (cpsi) for f colon X to Y where psi colon Y twoheadrightarrow c is the projection.","category":"page"},{"location":"Interface/AbelianCategories/#Semisimple-Categories","page":"Abelian Categories","title":"Semisimple Categories","text":"","category":"section"},{"location":"Interface/AbelianCategories/","page":"Abelian Categories","title":"Abelian Categories","text":"An abelian category is called semisimple if every object decomposes uniquely into a direct sum of simple objects. It might be useful to have the method","category":"page"},{"location":"Interface/AbelianCategories/","page":"Abelian Categories","title":"Abelian Categories","text":"simples(C::YourCategory)::Vector{YourObject}","category":"page"},{"location":"Interface/AbelianCategories/#Categories-with-fibre-functor","page":"Abelian Categories","title":"Categories with fibre functor","text":"","category":"section"},{"location":"Interface/AbelianCategories/","page":"Abelian Categories","title":"Abelian Categories","text":"Whenever a category mathcal C has a fibre functor, i.e. an exact faithful functor mathcal C to mathrmVec_k, we can use matrix calculus to compute technical things we often need to implement certain constructions. Implement an existing fibre functor by providing the a method","category":"page"},{"location":"Interface/AbelianCategories/","page":"Abelian Categories","title":"Abelian Categories","text":"matrix(f::MyMorphism)::MatElem","category":"page"},{"location":"ConcreteExamples/UqSl2/#Representations-of-\\mathfrak{sl}_2(\\mathbb-k)","page":"Representations of  U_q(mathfraksl_2(K))","title":"Representations of mathfraksl_2(mathbb k)","text":"","category":"section"},{"location":"ConcreteExamples/UqSl2/","page":"Representations of  U_q(mathfraksl_2(K))","title":"Representations of  U_q(mathfraksl_2(K))","text":"The representation category of mathfraksl_2(mathbb k) has countably infinte simple objects V_i mid i in mathbb N_0 where the tensor product is given by the  Clebsch-Gordon rule","category":"page"},{"location":"ConcreteExamples/UqSl2/","page":"Representations of  U_q(mathfraksl_2(K))","title":"Representations of  U_q(mathfraksl_2(K))","text":"V_i otimes V_j = limits_l = 0^min(ij) V_i+j - 2l","category":"page"},{"location":"ConcreteExamples/UqSl2/","page":"Representations of  U_q(mathfraksl_2(K))","title":"Representations of  U_q(mathfraksl_2(K))","text":"We can construct the category and specify at any value for q that is either 1 or not  a rot of unity.","category":"page"},{"location":"ConcreteExamples/UqSl2/","page":"Representations of  U_q(mathfraksl_2(K))","title":"Representations of  U_q(mathfraksl_2(K))","text":"sl2_representations","category":"page"},{"location":"ConcreteExamples/UqSl2/#TensorCategories.sl2_representations-ConcreteExamples-UqSl2","page":"Representations of  U_q(mathfraksl_2(K))","title":"TensorCategories.sl2_representations","text":"sl2_representations(F::Ring)\nsl2_representations(F::Ring, q::RingElem)\n\nConstruct a skeletal category equivalent to the category of representations of 𝔰𝔩₂(F) specialized at q. q defaults to 1.\n\n\n\n\n\n","category":"function"},{"location":"ConcreteExamples/UqSl2/#Verlinde-type-categories","page":"Representations of  U_q(mathfraksl_2(K))","title":"Verlinde type categories","text":"","category":"section"},{"location":"ConcreteExamples/UqSl2/","page":"Representations of  U_q(mathfraksl_2(K))","title":"Representations of  U_q(mathfraksl_2(K))","text":"When specifying at a root of unity we arrive at the Verlinde category.  These categoryies have n simple objects V_0V_n-1and fusion rule ","category":"page"},{"location":"ConcreteExamples/UqSl2/","page":"Representations of  U_q(mathfraksl_2(K))","title":"Representations of  U_q(mathfraksl_2(K))","text":"V_i otimes V_j = limits_l = 0^min(ij) V_i+j - 2l","category":"page"},{"location":"Interface/LinearCategories/#Linear-Categories","page":"Linear Categories","title":"Linear Categories","text":"","category":"section"},{"location":"Interface/LinearCategories/","page":"Linear Categories","title":"Linear Categories","text":"Let k be any field. A category is called k-linear whenever it is enriched over the category of k-vector spaces, i.e. all Hom-spaces are k-vector spaces and composition is k-linear. We need the following method:","category":"page"},{"location":"Interface/LinearCategories/","page":"Linear Categories","title":"Linear Categories","text":"*(λ, f::YourMorphism)::YourMorphism returning the multiplication if a scalar λ.","category":"page"},{"location":"Interface/LinearCategories/#Rational-Forms","page":"Linear Categories","title":"Rational Forms","text":"","category":"section"},{"location":"Interface/LinearCategories/","page":"Linear Categories","title":"Linear Categories","text":"In the literature most categories are defined over an algebraically closed field of characteristic 0 or even over mathbb C. This is technically possible to implement utilizing the implementation of algebraic numbers in Nemo.jl.","category":"page"},{"location":"Interface/LinearCategories/","page":"Linear Categories","title":"Linear Categories","text":"In general it is very interesting to work with categories not defined over algebraically closed fields. Especially it might be of interest to implement a category that is usually defined over mathbb C over a finite extension of mathbb Q. ","category":"page"},{"location":"Interface/LinearCategories/","page":"Linear Categories","title":"Linear Categories","text":"Let mathcal C be a K-linear category and k subset K a field extension. Then a category overlinemathcal C is called a rational form for mathcal C if the karoubian envelope of overlinemathcal C otimes K is equivalent to mathcal C. We call the rational form complete if already overlinemathcal C otimes K is equivalent to mathcal C.","category":"page"},{"location":"Interface/LinearCategories/","page":"Linear Categories","title":"Linear Categories","text":"Unfortunately the notion of a complete rational form violates the principle of equivalence. For example the center construction does not preserve the completeness of the rational form. ","category":"page"},{"location":"References/#References","page":"References","title":"References","text":"","category":"section"},{"location":"References/","page":"References","title":"References","text":"P. Etingof, S. Gelaki, D. Nikshych and V. Ostrik. Tensor categories. Vol. 205 (American Mathematical Soc., 2016).\n\n\n\nD. Tambara and S. Yamagami. Tensor Categories with Fusion Rules of Self-Duality for Finite Abelian Groups. Journal of Algebra 209, 692–707 (1998).\n\n\n\nR. Wolf. Microscopic models for fusion categories, arXiv preprint arXiv:2101.04154 (2021).\n\n\n\nG. Vercleyen and J. Slingerland. On Low Rank Fusion Rings (2023), arXiv:2205.15637 [math-ph].\n\n\n\nF. Mäurer and U. Thiel. Computing the center of a fusion category, arXiv preprint arXiv:2406.13438 (2024).\n\n\n\n","category":"page"},{"location":"ConcreteExamples/Representations/","page":"Group Representations","title":"Group Representations","text":"CurrentModule = TensorCategories","category":"page"},{"location":"ConcreteExamples/Representations/#Representations","page":"Group Representations","title":"Representations","text":"","category":"section"},{"location":"ConcreteExamples/Representations/","page":"Group Representations","title":"Group Representations","text":"We provide a simple abstract type hierarchy for representation categories:","category":"page"},{"location":"ConcreteExamples/Representations/","page":"Group Representations","title":"Group Representations","text":"abstract type RepresentationCategory <:Category","category":"page"},{"location":"ConcreteExamples/Representations/#Representations-of-Finite-groups","page":"Group Representations","title":"Representations of Finite groups","text":"","category":"section"},{"location":"ConcreteExamples/Representations/","page":"Group Representations","title":"Group Representations","text":"Let G be a finite group. We consider the category of finite dimensional k-representations of G.","category":"page"},{"location":"ConcreteExamples/Representations/","page":"Group Representations","title":"Group Representations","text":"GroupRepresentationCategory <: RepresentationCategory","category":"page"},{"location":"ConcreteExamples/Representations/","page":"Group Representations","title":"Group Representations","text":"Build it with the constructor","category":"page"},{"location":"ConcreteExamples/Representations/","page":"Group Representations","title":"Group Representations","text":"representation_category(::Field, ::Group)","category":"page"},{"location":"ConcreteExamples/Representations/#TensorCategories.representation_category-Tuple{Field, AbstractAlgebra.Group}-ConcreteExamples-Representations","page":"Group Representations","title":"TensorCategories.representation_category","text":"representation_category(F::Field, G::Group)\n\nCategory of finite dimensonal group representations of G.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/Representations/","page":"Group Representations","title":"Group Representations","text":"A group representation is defined by a group homomorphism from G into a finite dimensional vector space k^n. These objects are of type","category":"page"},{"location":"ConcreteExamples/Representations/","page":"Group Representations","title":"Group Representations","text":"GroupRepresentationObject <: RepresentationObject","category":"page"},{"location":"ConcreteExamples/Representations/","page":"Group Representations","title":"Group Representations","text":"They are constructed in one of two ways, either by images of generators or by a function","category":"page"},{"location":"ConcreteExamples/Representations/","page":"Group Representations","title":"Group Representations","text":"Representation(::Group,::Vector,::Vector)\nRepresentation(::Group,::Function)","category":"page"},{"location":"ConcreteExamples/Representations/#TensorCategories.Representation-Tuple{AbstractAlgebra.Group, Vector, Vector}-ConcreteExamples-Representations","page":"Group Representations","title":"TensorCategories.Representation","text":"Representation(G::Group, pre_img::Vector, img::Vector)\n\nGroup representation defined by the images of generators of G.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/Representations/#TensorCategories.Representation-Tuple{AbstractAlgebra.Group, Function}-ConcreteExamples-Representations","page":"Group Representations","title":"TensorCategories.Representation","text":"Representation(G::Group, m::Function)\n\nGroup representation defined by m:G -> Mat_n.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/Representations/","page":"Group Representations","title":"Group Representations","text":"where in both cases the images are required to be fitting MatrixElem objects.","category":"page"},{"location":"ConcreteExamples/Representations/","page":"Group Representations","title":"Group Representations","text":"Since group representation categories are tensor categories, we again have methods for the important operations","category":"page"},{"location":"ConcreteExamples/Representations/","page":"Group Representations","title":"Group Representations","text":"Modules = [TensorCategories]\nPages = [\"GroupRepresentations.jl\"]\nPrivate = false","category":"page"},{"location":"ConcreteExamples/Representations/#AbstractAlgebra.direct_sum-Tuple{GroupRepresentation, GroupRepresentation}","page":"Group Representations","title":"AbstractAlgebra.direct_sum","text":"direct_sum(ρ::GroupRepresentation, τ::GroupRepresentation, morphisms::Bool = false)\n\nReturn the direct sum of representations with the corresponding injections und projections.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/Representations/#AbstractAlgebra.direct_sum-Tuple{GroupRepresentationMorphism, GroupRepresentationMorphism}","page":"Group Representations","title":"AbstractAlgebra.direct_sum","text":"direct_sum(f::GroupRepresentationMorphism, g::GroupRepresentationMorphism)\n\nDirect sum of morphisms of representations.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/Representations/#Base.one-Tuple{GroupRepresentationCategory}","page":"Group Representations","title":"Base.one","text":"one(Rep::GroupRepresentationCategory)\n\nReturn the trivial representation.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/Representations/#Base.parent-Tuple{GroupRepresentation}","page":"Group Representations","title":"Base.parent","text":"parent(ρ::GroupRepresentation)\n\nReturn the parent representation category of ρ.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/Representations/#Base.zero-Tuple{GroupRepresentationCategory}","page":"Group Representations","title":"Base.zero","text":"zero(Rep::GroupRepresentationCategory)\n\nReturn the zero reprensentation.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/Representations/#Hecke.decompose-Tuple{GroupRepresentation}","page":"Group Representations","title":"Hecke.decompose","text":"decompose(σ::GroupRepresentation)\n\nDecompose the representation into a direct sum of simple objects. Return a list of tuples with simple objects and multiplicities.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/Representations/#Hecke.id-Tuple{GroupRepresentation}","page":"Group Representations","title":"Hecke.id","text":"id(ρ::GroupRepresentation)\n\nReturn the identity on ρ.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/Representations/#Hecke.is_semisimple-Tuple{GroupRepresentationCategory}","page":"Group Representations","title":"Hecke.is_semisimple","text":"is_semisimple(C::GroupRepresentationCategory)\n\nReturn true if C is semisimple else false.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/Representations/#Hecke.tensor_product-Tuple{GroupRepresentation, GroupRepresentation}","page":"Group Representations","title":"Hecke.tensor_product","text":"tensor_product(ρ::GroupRepresentation, τ::GroupRepresentation)\n\nReturn the tensor product of representations.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/Representations/#Hecke.tensor_product-Tuple{GroupRepresentationMorphism, GroupRepresentationMorphism}","page":"Group Representations","title":"Hecke.tensor_product","text":"tensor_product(f::GroupRepresentationMorphism, g::GroupRepresentationMorphism)\n\nReturn the tensor product of morphisms of representations.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/Representations/#Oscar.morphism-Tuple{GroupRepresentation, GroupRepresentation, MatElem}","page":"Group Representations","title":"Oscar.morphism","text":"morphism(ρ::GroupRepresentation, τ::GroupRepresentation, m::MatElem; check = true)\n\nMorphism between representations defined by m. If check == false equivariancy will not be checked.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/Representations/#TensorCategories.Hom-Tuple{GroupRepresentation, GroupRepresentation}","page":"Group Representations","title":"TensorCategories.Hom","text":"Hom(σ::GroupRepresentation, τ::GroupRepresentation)\n\nReturn the hom-space of the representations as a vector space.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/Representations/#TensorCategories.Representation-Tuple{AbstractAlgebra.Group, Function}","page":"Group Representations","title":"TensorCategories.Representation","text":"Representation(G::Group, m::Function)\n\nGroup representation defined by m:G -> Mat_n.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/Representations/#TensorCategories.Representation-Tuple{AbstractAlgebra.Group, Vector, Vector}","page":"Group Representations","title":"TensorCategories.Representation","text":"Representation(G::Group, pre_img::Vector, img::Vector)\n\nGroup representation defined by the images of generators of G.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/Representations/#TensorCategories.representation_category-Tuple{Field, AbstractAlgebra.Group}","page":"Group Representations","title":"TensorCategories.representation_category","text":"representation_category(F::Field, G::Group)\n\nCategory of finite dimensonal group representations of G.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/Representations/#TensorCategories.simples-Tuple{GroupRepresentationCategory}","page":"Group Representations","title":"TensorCategories.simples","text":"simples(Rep::GroupRepresentationCategory)\n\nReturn a list of the simples objects in Rep.\n\n\n\n\n\n","category":"method"},{"location":"SixJCategories/SixJCategories/#6j_categories","page":"6j-Symbols","title":"Fusion Categories from 6j-Symbols","text":"","category":"section"},{"location":"SixJCategories/SixJCategories/","page":"6j-Symbols","title":"6j-Symbols","text":"In most literature concerning fusion categories they are characterized by  so called 6j-symbols. Often only those and the fusion rules are provided or of interest. Thus we provide a datatype that allows to  get a workable fusion category from provided `6j-symbols.","category":"page"},{"location":"SixJCategories/SixJCategories/#6j-Symbols","page":"6j-Symbols","title":"6j-Symbols","text":"","category":"section"},{"location":"SixJCategories/SixJCategories/","page":"6j-Symbols","title":"6j-Symbols","text":"Let mathcal C be a locally finite semisimple multitensor category.  Then, if X_imid i in mathcal I is a collection of the non-isomorphic simple objects, there is an equivalence of abelian categories ","category":"page"},{"location":"SixJCategories/SixJCategories/","page":"6j-Symbols","title":"6j-Symbols","text":"F colon mathcal C cong bigopluslimits_i in mathcal I mathrmVec_k","category":"page"},{"location":"SixJCategories/SixJCategories/","page":"6j-Symbols","title":"6j-Symbols","text":"given by ","category":"page"},{"location":"SixJCategories/SixJCategories/","page":"6j-Symbols","title":"6j-Symbols","text":"X mapsto mathrmHom(X_iX)","category":"page"},{"location":"SixJCategories/SixJCategories/","page":"6j-Symbols","title":"6j-Symbols","text":"We define H_ij^k = mathrmHom(X_k X_iotimes X_j) to be the multiplicity spaces. Now considering the image of a tensor product X_i otimes X_j of two simple objects we obtain ","category":"page"},{"location":"SixJCategories/SixJCategories/","page":"6j-Symbols","title":"6j-Symbols","text":"X_i otimes X_j mapsto bigopluslimits_k in mathcal I H_ij^k","category":"page"},{"location":"SixJCategories/SixJCategories/","page":"6j-Symbols","title":"6j-Symbols","text":"After fixing a natural isomorphism ","category":"page"},{"location":"SixJCategories/SixJCategories/","page":"6j-Symbols","title":"6j-Symbols","text":"(X_i otimes X_j) otimes X_k cong X_i otimes (X_j otimes X_k)","category":"page"},{"location":"SixJCategories/SixJCategories/","page":"6j-Symbols","title":"6j-Symbols","text":"we obtain morphisms ","category":"page"},{"location":"SixJCategories/SixJCategories/","page":"6j-Symbols","title":"6j-Symbols","text":"bigopluslimits_k  I H_ij^k xrightarrow","category":"page"},{"location":"SixJCategories/SixJCategories/","page":"6j-Symbols","title":"6j-Symbols","text":"Modules = [TensorCategories]\nPages = [\"FusionCategory.jl\"]","category":"page"},{"location":"SixJCategories/SixJCategories/#Hecke.dual-Tuple{SixJObject}","page":"6j-Symbols","title":"Hecke.dual","text":"dual(X::SixJObject)\n\nReturn the dual object of X. An error is thrown if X is not rigid.\n\n\n\n\n\n","category":"method"},{"location":"SixJCategories/SixJCategories/#Oscar.GModuleFromGap.extension_of_scalars","page":"6j-Symbols","title":"Oscar.GModuleFromGap.extension_of_scalars","text":"extension_of_scalars(X::SixJObject, K::Field)\n\nReturn the object X as an object of the category CK.\n\n\n\n\n\n","category":"function"},{"location":"SixJCategories/SixJCategories/#Oscar.GModuleFromGap.extension_of_scalars-2","page":"6j-Symbols","title":"Oscar.GModuleFromGap.extension_of_scalars","text":"extension_of_scalars(f::SixJMorphism, K::Field)\n\nReturn the category CK.\n\n\n\n\n\n","category":"function"},{"location":"SixJCategories/SixJCategories/#Oscar.GModuleFromGap.extension_of_scalars-Tuple{SixJCategory, Ring}","page":"6j-Symbols","title":"Oscar.GModuleFromGap.extension_of_scalars","text":"extension_of_scalars(C::SixJCategory, K::Field)\n\nReturn the category CK.\n\n\n\n\n\n","category":"method"},{"location":"SixJCategories/SixJCategories/#TensorCategories.associator-Tuple{SixJObject, SixJObject, SixJObject}","page":"6j-Symbols","title":"TensorCategories.associator","text":"associator(X::SixJObject, Y::SixJObject, Z::SixJObject)\n\nReturn the associator isomorphism (X⊗Y)⊗Z → X⊗(Y⊗Z).\n\n\n\n\n\n","category":"method"},{"location":"Interface/Generic/#Generic-Methods","page":"Genericity","title":"Generic Methods","text":"","category":"section"},{"location":"Interface/Generic/","page":"Genericity","title":"Genericity","text":"Many constructions for additive, abelian, linear or monoidal categories are entangled. Thus we provide a  vast list of methods to compute objects or morphisms using other methods. ","category":"page"},{"location":"Interface/Generic/","page":"Genericity","title":"Genericity","text":"Keep in mind that the performance will usually be much better if the following methods are  overwritten form custom types. ","category":"page"},{"location":"Interface/Generic/","page":"Genericity","title":"Genericity","text":"Modules = [TensorCategories]\nPages = [\"AbstractMethods.jl\", \"Fallbacks.jl\"]\nPrivate = false","category":"page"},{"location":"Interface/Generic/#AbstractAlgebra.image-Tuple{Morphism}","page":"Genericity","title":"AbstractAlgebra.image","text":"image(f::Morphism)\n\nReturn the image Im(f) of fX  Y together with a monomorphism  Im(f)  Y.\n\n\n\n\n\n","category":"method"},{"location":"Interface/Generic/#Hecke.central_primitive_idempotents-Tuple{AbstractHomSpace}","page":"Genericity","title":"Hecke.central_primitive_idempotents","text":"central_primitive_idempotents(H::AbstractHomSpace)\n\nCompute the central primitive idempotents of an endomorphism space H.\n\n\n\n\n\n","category":"method"},{"location":"Interface/Generic/#Hecke.decompose-Tuple{Object}","page":"Genericity","title":"Hecke.decompose","text":"decompose(X::Object)\n\nDecompose an object X in an abelian category.\n\n\n\n\n\n","category":"method"},{"location":"Interface/Generic/#Hecke.decompose-Union{Tuple{T}, Tuple{T, Vector{T}}} where T<:Object","page":"Genericity","title":"Hecke.decompose","text":"decompose(X::Object, S::Vector{Object})\n\nDecompose an object X in a semisimple category into simple objects of S.\n\n\n\n\n\n","category":"method"},{"location":"Interface/Generic/#Hecke.is_simple-Tuple{Object}","page":"Genericity","title":"Hecke.is_simple","text":"is_simple(X::Object)\n\nCheck whether X is a simple object.  \n\n\n\n\n\n","category":"method"},{"location":"Interface/Generic/#Nemo.eigenvalues-Tuple{Morphism}","page":"Genericity","title":"Nemo.eigenvalues","text":"eigenvalues(f::Morphism)\n\nCompute the eigenvalues of f. Return a dictonary with  entries λ => ker(f - λid).\n\n\n\n\n\n","category":"method"},{"location":"Interface/Generic/#TensorCategories.endomorphism_ring","page":"Genericity","title":"TensorCategories.endomorphism_ring","text":"endomorphism_ring(X::Object)\n\nReturn the endomorphism ring of X as a matrix algebra.\n\n\n\n\n\n","category":"function"},{"location":"Interface/Generic/#TensorCategories.express_in_basis","page":"Genericity","title":"TensorCategories.express_in_basis","text":"express_in_basis(f::Morphism)\n\nReturn a vector of coefficients expressing f X  Y in the basis o f mathrmHom(XY).\n\n\n\n\n\n","category":"function"},{"location":"Interface/Generic/#TensorCategories.express_in_basis-Union{Tuple{T}, Tuple{T, Vector{T}}} where T<:Morphism","page":"Genericity","title":"TensorCategories.express_in_basis","text":"express_in_basis(f::Morphism, B::Vector{Morphism})\n\nReturn a vector of coefficients expressing fin the basis B.\n\n\n\n\n\n","category":"method"},{"location":"Interface/Generic/#TensorCategories.horizontal_direct_sum-Tuple{Morphism, Morphism}","page":"Genericity","title":"TensorCategories.horizontal_direct_sum","text":"function horizontal_direct_sum(f::Morphism, g::Morphism)\n\nReturn the sum of fX  Z, gY  Z as ``f+g:X⊕Y → Z.\n\n\n\n\n\n","category":"method"},{"location":"Interface/Generic/#TensorCategories.is_epimorphism-Tuple{Morphism}","page":"Genericity","title":"TensorCategories.is_epimorphism","text":"is_epimorphism(f::Morphism)\n\nCheck wether fis epi.\n\n\n\n\n\n","category":"method"},{"location":"Interface/Generic/#TensorCategories.is_monomorphism-Tuple{Morphism}","page":"Genericity","title":"TensorCategories.is_monomorphism","text":"is_monomoprhism(f::Morphism)\n\nCheck whether f mono.\n\n\n\n\n\n","category":"method"},{"location":"Interface/Generic/#TensorCategories.left_inverse-Tuple{Morphism}","page":"Genericity","title":"TensorCategories.left_inverse","text":"left_inverse(f::Morphism)\n\nCompute a morphism g such that g  f = id. Errors if  fis not mono. \n\n\n\n\n\n","category":"method"},{"location":"Interface/Generic/#TensorCategories.right_inverse-Tuple{Morphism}","page":"Genericity","title":"TensorCategories.right_inverse","text":"right_inverse(f::Morphism)\n\nCompute a morphism g such that f  g = id. Errors if f is not epi.\n\n\n\n\n\n","category":"method"},{"location":"Interface/Generic/#TensorCategories.vertical_direct_sum-Tuple{Morphism, Morphism}","page":"Genericity","title":"TensorCategories.vertical_direct_sum","text":"function vertical_direct_sum(f::Morphism, g::Morphism)\n\nReturn the sum of fX  Y, gX  Z as ``f+g: X → Y⊕Z.\n\n\n\n\n\n","category":"method"},{"location":"Interface/Generic/#TensorCategories.zero_morphism-Tuple{Object, Object}","page":"Genericity","title":"TensorCategories.zero_morphism","text":"zero_morphism(X::Object, Y::Object)\n\nCompute the zero morphism between Xand Y.\n\n\n\n\n\n","category":"method"},{"location":"Interface/Generic/#TensorCategories.zero_morphism-Tuple{Object}","page":"Genericity","title":"TensorCategories.zero_morphism","text":"zero_morphism(X::Object)\n\nCompute the zero morphism on X.\n\n\n\n\n\n","category":"method"},{"location":"Interface/Generic/#Base.:^-Tuple{Object, Any}","page":"Genericity","title":"Base.:^","text":"^(X::Object, n::Integer)\n\nReturn the n-fold product object X^n.\n\n\n\n\n\n","category":"method"},{"location":"Interface/Generic/#Hecke.:⊗-Tuple{Morphism, Morphism}","page":"Genericity","title":"Hecke.:⊗","text":"⊗(f::Morphism, g::Morphism)\n\nReturn the tensor product morphism of fand g.\n\n\n\n\n\n","category":"method"},{"location":"Interface/Generic/#Hecke.:⊗-Union{Tuple{Vararg{T}}, Tuple{T}} where T<:Object","page":"Genericity","title":"Hecke.:⊗","text":"⊗(X::Object...)\n\nReturn the tensor product object.\n\n\n\n\n\n","category":"method"},{"location":"Interface/Generic/#TensorCategories.:×-Tuple{Vararg{Object}}","page":"Genericity","title":"TensorCategories.:×","text":"×(X::Object...)\n\nReturn the product Object and an array containing the projection morphisms.\n\n\n\n\n\n","category":"method"},{"location":"Interface/Generic/#TensorCategories.∐-Tuple{Vararg{Object}}","page":"Genericity","title":"TensorCategories.∐","text":"∐(X::Object...)\n\nReturn the coproduct Object and an array containing the injection morphisms.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/","page":"Equivariant Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"CurrentModule = TensorCategories","category":"page"},{"location":"ConcreteExamples/CoherentSheaves/#Coherent-sheaves-on-Finite-Sets","page":"Equivariant Coherent Sheaves","title":"Coherent sheaves on Finite Sets","text":"","category":"section"},{"location":"ConcreteExamples/CoherentSheaves/","page":"Equivariant Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"Coherent sheaves on a finite set X are characterized by the stalks of the the elements x in X. I.e. a coherent sheaf on X is a collection of vector spaces V_x for each xin X. More generally for a group G and a G-set X we can define consider G-equivariant sheaves on X. In this case a sheaf is specified by representations of the stabilizers of representatives for the orbits.","category":"page"},{"location":"ConcreteExamples/CoherentSheaves/#Equivariant-Coherent-Sheaves","page":"Equivariant Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"","category":"section"},{"location":"ConcreteExamples/CoherentSheaves/","page":"Equivariant Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"We provide the datatype","category":"page"},{"location":"ConcreteExamples/CoherentSheaves/","page":"Equivariant Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"CoherentSheafObject <: Object","category":"page"},{"location":"ConcreteExamples/CoherentSheaves/","page":"Equivariant Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"The category of equivariant coherent sheaves has type","category":"page"},{"location":"ConcreteExamples/CoherentSheaves/","page":"Equivariant Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"CohSheaves <: MultiTensorCategory","category":"page"},{"location":"ConcreteExamples/CoherentSheaves/","page":"Equivariant Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"and can be constructed via","category":"page"},{"location":"ConcreteExamples/CoherentSheaves/","page":"Equivariant Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"coherent_sheaves","category":"page"},{"location":"ConcreteExamples/CoherentSheaves/#TensorCategories.coherent_sheaves","page":"Equivariant Coherent Sheaves","title":"TensorCategories.coherent_sheaves","text":"coherent_sheaves(X::GSet,F::Field)\n\nThe category of G-equivariant coherent sheafes on X.\n\n\n\n\n\ncoherent_sheaves(X, F::Field)\n\nThe category of coherent sheafes on X.\n\n\n\n\n\n","category":"function"},{"location":"ConcreteExamples/CoherentSheaves/","page":"Equivariant Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"Morphisms are given by morphisms of representations of the stalks and are of type","category":"page"},{"location":"ConcreteExamples/CoherentSheaves/","page":"Equivariant Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"CohSheafMorphism{T,G} <: Morphism","category":"page"},{"location":"ConcreteExamples/CoherentSheaves/","page":"Equivariant Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"Modules = [TensorCategories]\nPages = [\"CoherentSheaves.jl\"]","category":"page"},{"location":"ConcreteExamples/CoherentSheaves/#AbstractAlgebra.compose-Tuple{TensorCategories.CohSheafMorphism, TensorCategories.CohSheafMorphism}","page":"Equivariant Coherent Sheaves","title":"AbstractAlgebra.compose","text":"compose(f::CohSheafMorphism, g::CohSheafMorphism)\n\nReturn the composition g∘f.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#AbstractAlgebra.direct_sum-Tuple{TensorCategories.CohSheafMorphism, TensorCategories.CohSheafMorphism}","page":"Equivariant Coherent Sheaves","title":"AbstractAlgebra.direct_sum","text":"direct_sum(f::CohSheafMorphism, g::CohSheafMorphism)\n\nReturn the direct sum of morphisms of sheaves.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#AbstractAlgebra.direct_sum-Tuple{TensorCategories.CohSheafObject, TensorCategories.CohSheafObject}","page":"Equivariant Coherent Sheaves","title":"AbstractAlgebra.direct_sum","text":"direct_sum(X::CohSheafObject, Y::CohSheafObject)\n\nReturn the direct sum of sheaves. Return also the inclusion and projection.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#AbstractAlgebra.is_isomorphic-Tuple{TensorCategories.CohSheafObject, TensorCategories.CohSheafObject}","page":"Equivariant Coherent Sheaves","title":"AbstractAlgebra.is_isomorphic","text":"is_isomorphic(X::CohSheafObject, Y::CohSheafObject)\n\nCheck whether Xand Y are isomorphic and the isomorphism if possible.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#AbstractAlgebra.kernel-Tuple{TensorCategories.CohSheafMorphism}","page":"Equivariant Coherent Sheaves","title":"AbstractAlgebra.kernel","text":"kernel(f::CohSheafMorphism)\n\nReturn a tuple (K,k) where K is the kernel object and k is the inclusion.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#Base.inv-Tuple{TensorCategories.CohSheafMorphism}","page":"Equivariant Coherent Sheaves","title":"Base.inv","text":"inv(f::CohSheafMorphism)\n\nRetrn the inverse morphism of f.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#Base.one-Tuple{TensorCategories.CohSheaves}","page":"Equivariant Coherent Sheaves","title":"Base.one","text":"one(C::CohSheaves)\n\nReturn the one object in C.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#Base.zero-Tuple{TensorCategories.CohSheaves}","page":"Equivariant Coherent Sheaves","title":"Base.zero","text":"zero(C::CohSheaves)\n\nReturn the zero sheaf on the G-set.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#Hecke.cokernel-Tuple{TensorCategories.CohSheafMorphism}","page":"Equivariant Coherent Sheaves","title":"Hecke.cokernel","text":"cokernel(f::CohSheafMorphism)\n\nReturn a tuple (C,c) where C is the kernel object and c is the projection.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#Hecke.decompose-Tuple{TensorCategories.CohSheafObject}","page":"Equivariant Coherent Sheaves","title":"Hecke.decompose","text":"decompose(X::CohSheafObject)\n\nDecompose X into a direct sum of simple objects with multiplicity.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#Hecke.dual-Tuple{TensorCategories.CohSheafObject}","page":"Equivariant Coherent Sheaves","title":"Hecke.dual","text":"dual(X::CohSheafObject)\n\nReturn the dual object of X.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#Hecke.id-Tuple{TensorCategories.CohSheafObject}","page":"Equivariant Coherent Sheaves","title":"Hecke.id","text":"id(X::CohSheafObject)\n\nReturn the identity on X.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#Hecke.is_semisimple-Tuple{TensorCategories.CohSheaves}","page":"Equivariant Coherent Sheaves","title":"Hecke.is_semisimple","text":"is_semisimple(C::CohSheaves)\n\nReturn whether Cis semisimple.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#Hecke.tensor_product-Tuple{TensorCategories.CohSheafMorphism, TensorCategories.CohSheafMorphism}","page":"Equivariant Coherent Sheaves","title":"Hecke.tensor_product","text":"tensor_product(f::CohSheafMorphism, g::CohSheafMorphism)\n\nReturn the tensor product of morphisms of equivariant coherent sheaves.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#Hecke.tensor_product-Tuple{TensorCategories.CohSheafObject, TensorCategories.CohSheafObject}","page":"Equivariant Coherent Sheaves","title":"Hecke.tensor_product","text":"tensor_product(X::CohSheafObject, Y::CohSheafObject)\n\nReturn the tensor product of equivariant coherent sheaves.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#TensorCategories.Hom-Tuple{TensorCategories.CohSheafObject, TensorCategories.CohSheafObject}","page":"Equivariant Coherent Sheaves","title":"TensorCategories.Hom","text":"Hom(X::CohSheafObject, Y::CohSheafObject)\n\nReturn Hom(XY) as a vector space.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#TensorCategories.Pullback-Tuple{TensorCategories.CohSheaves, TensorCategories.CohSheaves, Function}","page":"Equivariant Coherent Sheaves","title":"TensorCategories.Pullback","text":"Pullback(C::CohSheaves, D::CohSheaves, f::Function)\n\nReturn the pullback functor C → D defined by the G-set map f::X → Y.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#TensorCategories.Pushforward-Tuple{TensorCategories.CohSheaves, TensorCategories.CohSheaves, Function}","page":"Equivariant Coherent Sheaves","title":"TensorCategories.Pushforward","text":"Pushforward(C::CohSheaves, D::CohSheaves, f::Function)\n\nReturn the push forward functor C → D defined by the G-set map f::X → Y.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#TensorCategories.associator-Tuple{TensorCategories.CohSheafObject, TensorCategories.CohSheafObject, TensorCategories.CohSheafObject}","page":"Equivariant Coherent Sheaves","title":"TensorCategories.associator","text":"associator(X::CohSheafObject, Y::CohSheafObject, Z::CohSheafObject)\n\nReturn the associator isomorphism (X⊗Y)⊗Z → X⊗(Y⊗Z).\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#TensorCategories.braiding-Tuple{TensorCategories.CohSheafObject, TensorCategories.CohSheafObject}","page":"Equivariant Coherent Sheaves","title":"TensorCategories.braiding","text":"braiding(X::cohSheaf, Y::CohSheafObject)\n\nReturn the braiding isomoephism X⊗Y → Y⊗X.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#TensorCategories.coev-Tuple{TensorCategories.CohSheafObject}","page":"Equivariant Coherent Sheaves","title":"TensorCategories.coev","text":"coev(X::CohSheafObject)\n\nReturn the coevaluation morphism 1 → X⊗X∗.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#TensorCategories.coherent_sheaves-Tuple{Field, Any}","page":"Equivariant Coherent Sheaves","title":"TensorCategories.coherent_sheaves","text":"coherent_sheaves(X, F::Field)\n\nThe category of coherent sheafes on X.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#TensorCategories.coherent_sheaves-Tuple{Field, GSet}","page":"Equivariant Coherent Sheaves","title":"TensorCategories.coherent_sheaves","text":"coherent_sheaves(X::GSet,F::Field)\n\nThe category of G-equivariant coherent sheafes on X.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#TensorCategories.ev-Tuple{TensorCategories.CohSheafObject}","page":"Equivariant Coherent Sheaves","title":"TensorCategories.ev","text":"ev(X::CohSheafObject)\n\nReturn the evaluation morphism X∗⊗X → 1.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#TensorCategories.simples-Tuple{TensorCategories.CohSheaves}","page":"Equivariant Coherent Sheaves","title":"TensorCategories.simples","text":"simples(C::CohSheaves)\n\nReturn the simple objects of C.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#TensorCategories.spherical-Tuple{TensorCategories.CohSheafObject}","page":"Equivariant Coherent Sheaves","title":"TensorCategories.spherical","text":"spherical(X::CohSheafObject)\n\nReturn the spherical structure isomorphism X → X∗∗.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#TensorCategories.stalks-Tuple{TensorCategories.CohSheafObject}","page":"Equivariant Coherent Sheaves","title":"TensorCategories.stalks","text":"stalks(X::CohSheafObject)\n\nReturn the stalks of X.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#TensorCategories.zero_morphism-Tuple{TensorCategories.CohSheafObject, TensorCategories.CohSheafObject}","page":"Equivariant Coherent Sheaves","title":"TensorCategories.zero_morphism","text":"zero_morphism(X::CohSheafObject, Y::CohSheafObject)\n\nReturn the zero morphism 0:X → Y.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#Convolution-Category","page":"Equivariant Coherent Sheaves","title":"Convolution Category","text":"","category":"section"},{"location":"ConcreteExamples/CoherentSheaves/","page":"Equivariant Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"The objects of this category are again G-equivariant coherent sheaves on a finite G-set Xtimes X. But we endow them with a different monoidal product.","category":"page"},{"location":"ConcreteExamples/CoherentSheaves/","page":"Equivariant Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"Let p_ij Xtimes Xtimes X to X times X be the canonical projections. Then we define the monoidal product of two coherent sheaves x and y","category":"page"},{"location":"ConcreteExamples/CoherentSheaves/","page":"Equivariant Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"beginaligned\nxotimes y = p_13_ast(p_12^ast(x)otimes p_23^ast(y))\nendaligned","category":"page"},{"location":"ConcreteExamples/CoherentSheaves/","page":"Equivariant Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"where otimesis the monoidal product of Coh(Xtimes Xtimes X). Similar for morphisms.","category":"page"},{"location":"ConcreteExamples/CoherentSheaves/","page":"Equivariant Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"Objects in this category are of type","category":"page"},{"location":"ConcreteExamples/CoherentSheaves/","page":"Equivariant Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"ConvolutionObject <: Object","category":"page"},{"location":"ConcreteExamples/CoherentSheaves/","page":"Equivariant Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"while the convolution category is of type","category":"page"},{"location":"ConcreteExamples/CoherentSheaves/","page":"Equivariant Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"ConvolutionCategory <: MultiTensorCategory","category":"page"},{"location":"ConcreteExamples/CoherentSheaves/","page":"Equivariant Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"and can be constructed by","category":"page"},{"location":"ConcreteExamples/CoherentSheaves/","page":"Equivariant Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"convolution_category","category":"page"},{"location":"ConcreteExamples/CoherentSheaves/#TensorCategories.convolution_category","page":"Equivariant Coherent Sheaves","title":"TensorCategories.convolution_category","text":"convolution_category( K::Field, X::GSet)\n\nReturn the category of equivariant coherent sheaves on X with convolution product.\n\n\n\n\n\nconvolution_category(K::Field, X)\n\nReturn the category of coherent sheaves on X with convolution product.\n\n\n\n\n\n","category":"function"},{"location":"ConcreteExamples/CoherentSheaves/","page":"Equivariant Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"Morphisms are just morphisms of coherent sheaves with the new tensor product.","category":"page"},{"location":"ConcreteExamples/CoherentSheaves/","page":"Equivariant Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"ConvolutionMorphism <: Morphism","category":"page"},{"location":"ConcreteExamples/CoherentSheaves/","page":"Equivariant Coherent Sheaves","title":"Equivariant Coherent Sheaves","text":"Modules = [TensorCategories]\nPages = [\"ConvolutionCategory.jl\"]","category":"page"},{"location":"ConcreteExamples/CoherentSheaves/#AbstractAlgebra.direct_sum-Tuple{TensorCategories.ConvolutionMorphism, TensorCategories.ConvolutionMorphism}","page":"Equivariant Coherent Sheaves","title":"AbstractAlgebra.direct_sum","text":"direct_sum(f::ConvolutionMorphism, g::ConvolutionMorphism)\n\nReturn the direct sum of morphisms of coherent sheaves (with convolution product).\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#AbstractAlgebra.direct_sum-Tuple{TensorCategories.ConvolutionObject, TensorCategories.ConvolutionObject}","page":"Equivariant Coherent Sheaves","title":"AbstractAlgebra.direct_sum","text":"direct_sum(X::ConvolutionObject, Y::ConvolutionObject, morphisms::Bool = false)\n\ndocumentation\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#AbstractAlgebra.is_isomorphic-Tuple{TensorCategories.ConvolutionObject, TensorCategories.ConvolutionObject}","page":"Equivariant Coherent Sheaves","title":"AbstractAlgebra.is_isomorphic","text":"is_isomorphic(X::ConvolutionObject, Y::ConvolutionObject)\n\nCheck whether Xand Yare isomorphic. Return the isomorphism if true.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#Base.one-Tuple{TensorCategories.ConvolutionCategory}","page":"Equivariant Coherent Sheaves","title":"Base.one","text":"one(C::ConvolutionCategory)\n\nReturn the one object in Conv(X).\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#Base.zero-Tuple{TensorCategories.ConvolutionCategory}","page":"Equivariant Coherent Sheaves","title":"Base.zero","text":"zero(C::ConvolutionCategory)\n\nReturn the zero object in Conv(X).\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#Hecke.decompose-Tuple{TensorCategories.ConvolutionObject}","page":"Equivariant Coherent Sheaves","title":"Hecke.decompose","text":"decompose(X::ConvolutionObject)\n\nDecompose X into a direct sum of simple objects with multiplicities.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#Hecke.is_semisimple-Tuple{TensorCategories.ConvolutionCategory}","page":"Equivariant Coherent Sheaves","title":"Hecke.is_semisimple","text":"is_semisimple(C::ConvolutionCategory)\n\nCheck whether C semisimple.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#Hecke.tensor_product-Tuple{TensorCategories.ConvolutionMorphism, TensorCategories.ConvolutionMorphism}","page":"Equivariant Coherent Sheaves","title":"Hecke.tensor_product","text":"tensor_product(f::ConvolutionMorphism, g::ConvolutionMorphism)\n\nReturn the convolution product of morphisms of coherent sheaves.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#Hecke.tensor_product-Tuple{TensorCategories.ConvolutionObject, TensorCategories.ConvolutionObject}","page":"Equivariant Coherent Sheaves","title":"Hecke.tensor_product","text":"tensor_product(X::ConvolutionObject, Y::ConvolutionObject)\n\nReturn the convolution product of coherent sheaves.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#TensorCategories.Hom-Tuple{TensorCategories.ConvolutionObject, TensorCategories.ConvolutionObject}","page":"Equivariant Coherent Sheaves","title":"TensorCategories.Hom","text":"Hom(X::ConvolutionObject, Y::ConvolutionObject)\n\nReturn Hom(XY) as a vector space.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#TensorCategories.convolution_category-Tuple{Field, Any}","page":"Equivariant Coherent Sheaves","title":"TensorCategories.convolution_category","text":"convolution_category(K::Field, X)\n\nReturn the category of coherent sheaves on X with convolution product.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#TensorCategories.convolution_category-Tuple{Field, GSet}","page":"Equivariant Coherent Sheaves","title":"TensorCategories.convolution_category","text":"convolution_category( K::Field, X::GSet)\n\nReturn the category of equivariant coherent sheaves on X with convolution product.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#TensorCategories.orbit_stabilizers-Tuple{TensorCategories.ConvolutionCategory}","page":"Equivariant Coherent Sheaves","title":"TensorCategories.orbit_stabilizers","text":"orbit_stabilizers(C::ConvolutionCategory)\n\nReturn the stabilizers of representatives of the orbits.\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#TensorCategories.simples-Tuple{TensorCategories.ConvolutionCategory}","page":"Equivariant Coherent Sheaves","title":"TensorCategories.simples","text":"simples(C::ConvolutionCategory)\n\nReturn a list of simple objects in Conv(X).\n\n\n\n\n\n","category":"method"},{"location":"ConcreteExamples/CoherentSheaves/#TensorCategories.stalks-Tuple{TensorCategories.ConvolutionObject}","page":"Equivariant Coherent Sheaves","title":"TensorCategories.stalks","text":"stalks(X::ConvolutionObject)\n\nReturn the stalks of the sheaf X.\n\n\n\n\n\n","category":"method"},{"location":"Constructions/ModuleCategories/#Internal-Module-Categories","page":"Internal Module Categories","title":"Internal Module Categories","text":"","category":"section"},{"location":"Constructions/ModuleCategories/","page":"Internal Module Categories","title":"Internal Module Categories","text":"Let mathcal C be a fusion category. Any finite module category over mathcal Ccan be realized as an internal module category mathrmMod_A(mathcal C) for an algebra Ain mathcal C. ","category":"page"},{"location":"Constructions/ModuleCategories/#Finding-Algebras","page":"Internal Module Categories","title":"Finding Algebras","text":"","category":"section"},{"location":"Constructions/ModuleCategories/","page":"Internal Module Categories","title":"Internal Module Categories","text":"There are four kinds of algebras of interest. Let (Amu) be an algebra.","category":"page"},{"location":"Constructions/ModuleCategories/","page":"Internal Module Categories","title":"Internal Module Categories","text":"Algebra objects\nSeparable algebra objects, i.e. mcolon Aotimes A to Asplits as a bimodule morphisms","category":"page"},{"location":"Constructions/ModuleCategories/","page":"Internal Module Categories","title":"Internal Module Categories","text":"And if mathcal Cadmits a braiding c_--","category":"page"},{"location":"Constructions/ModuleCategories/","page":"Internal Module Categories","title":"Internal Module Categories","text":"Commutative algebras, i.e. m  c_AA = m\nEtale algebras, i.e. separable, commutative algebras.","category":"page"},{"location":"Constructions/ModuleCategories/","page":"Internal Module Categories","title":"Internal Module Categories","text":"We can find those structures by setting up a system of quadratic equations. Those systems are often of dimension greater then zero and hence we have to guess some solutions. ","category":"page"},{"location":"Constructions/ModuleCategories/","page":"Internal Module Categories","title":"Internal Module Categories","text":"algebra_structures\nseparable_algebra_structures\ncommutative_algebra_structures\netale_algebra_structures","category":"page"},{"location":"Constructions/ModuleCategories/#TensorCategories.algebra_structures","page":"Internal Module Categories","title":"TensorCategories.algebra_structures","text":"algebra_structures(X::Object)\nalgebra_structures(X::Object, unit::Morphism)\n\nReturn a set of algebra objects over X. An empty array is returned only if there are no algebra structures. If the algebr is not connected, i.e. Hom(𝟙X)  k, then a unit should be provided.\n\n\n\n\n\n","category":"function"},{"location":"Constructions/ModuleCategories/#TensorCategories.separable_algebra_structures","page":"Internal Module Categories","title":"TensorCategories.separable_algebra_structures","text":"separable_algebra_structures(X::Object)\nseparable_algebra_structures(X::Object, unit::Morphism)\n\nReturn a set of separable algebra objects over X. An empty array is returned only if there are no algebra structures. If the algebr is not connected, i.e. Hom(𝟙X)  k, then a unit should be provided.\n\n\n\n\n\n","category":"function"},{"location":"Constructions/ModuleCategories/#TensorCategories.commutative_algebra_structures","page":"Internal Module Categories","title":"TensorCategories.commutative_algebra_structures","text":"commutative_algebra_structures(X::Object)\ncommutative_algebra_structures(X::Object, unit::Morphism)\n\nReturn a set of commutative algebra objects over X. An empty array is returned only if there are no algebra structures. If the algebr is not connected, i.e. Hom(𝟙X)  k, then a unit should be provided.\n\n\n\n\n\n","category":"function"},{"location":"Constructions/ModuleCategories/#TensorCategories.etale_algebra_structures","page":"Internal Module Categories","title":"TensorCategories.etale_algebra_structures","text":"etale_algebra_structures(X::Object)\netale_algebra_structures(X::Object, unit::Morphism)\n\nReturn a set of separable algebra objects over X. An empty array is returned only if there are no algebra structures. If the algebr is not connected, i.e. Hom(𝟙X)  k, then a unit should be provided.\n\n\n\n\n\n","category":"function"},{"location":"Constructions/ModuleCategories/#Internal-Module-Categories-2","page":"Internal Module Categories","title":"Internal Module Categories","text":"","category":"section"},{"location":"Constructions/ModuleCategories/","page":"Internal Module Categories","title":"Internal Module Categories","text":"When obtained an algebra we can set up the left, right and bimodule categories. For compatible modules also the tensor product over A is available.","category":"page"},{"location":"Constructions/ModuleCategories/","page":"Internal Module Categories","title":"Internal Module Categories","text":"category_of_left_modules\ncategory_of_right_modules\ncategory_of_bimodules","category":"page"},{"location":"Constructions/ModuleCategories/#TensorCategories.category_of_left_modules","page":"Internal Module Categories","title":"TensorCategories.category_of_left_modules","text":"category_of_left_modules(A::AlgebraObject)\n\nReturn the category of left A modules in parent(A)\n\n\n\n\n\n","category":"function"},{"location":"Constructions/ModuleCategories/#TensorCategories.category_of_right_modules","page":"Internal Module Categories","title":"TensorCategories.category_of_right_modules","text":"category_of_right_modules(A::AlgebraObject)\n\nReturn the category of right A modules in parent(A).\n\n\n\n\n\n","category":"function"},{"location":"Constructions/ModuleCategories/#TensorCategories.category_of_bimodules","page":"Internal Module Categories","title":"TensorCategories.category_of_bimodules","text":"category_of_bimodules(A::AlgebraObject, B::AlgebraObject)\n\nReturn the category of A-B bimodules in parent(A)\n\n\n\n\n\ncategory_of_bimodules(A::AlgebraObject)\n\nReturn the category of A-A bimodules in parent(A)\n\n\n\n\n\n","category":"function"},{"location":"Constructions/ModuleCategories/","page":"Internal Module Categories","title":"Internal Module Categories","text":"Somtimes it might be handy to construct some free modules by hand:","category":"page"},{"location":"Constructions/ModuleCategories/","page":"Internal Module Categories","title":"Internal Module Categories","text":"free_right_module\nfree_left_module\nfree_bimodule\nfree_module","category":"page"},{"location":"Constructions/ModuleCategories/#TensorCategories.free_right_module","page":"Internal Module Categories","title":"TensorCategories.free_right_module","text":"free_right_module(X::Object, A::AlgebraObject)\n\nReturn the free right module XA\n\n\n\n\n\n","category":"function"},{"location":"Constructions/ModuleCategories/#TensorCategories.free_left_module","page":"Internal Module Categories","title":"TensorCategories.free_left_module","text":"free_left_module(X::Object, A::AlgebraObject)\n\nReturn the free left module AX\n\n\n\n\n\n","category":"function"},{"location":"Constructions/ModuleCategories/#TensorCategories.free_bimodule","page":"Internal Module Categories","title":"TensorCategories.free_bimodule","text":"free_bimodule(X::Object, A::AlgebraObject)\n\nReturn the free A-A bimodule AXA\n\n\n\n\n\nfree_bimodule(X::Object, A::AlgebraObject, B::AlgebraObject)\n\nReturn the free A-B bimodule AXB\n\n\n\n\n\n","category":"function"},{"location":"Constructions/ModuleCategories/#AbstractAlgebra.free_module","page":"Internal Module Categories","title":"AbstractAlgebra.free_module","text":"free_module(X::Object, M::ModuleCategory)\n\nReturn the free module of X in M\n\n\n\n\n\n","category":"function"},{"location":"Constructions/ModuleCategories/","page":"Internal Module Categories","title":"Internal Module Categories","text":"And also conversions from algebras and bimodules:","category":"page"},{"location":"Constructions/ModuleCategories/","page":"Internal Module Categories","title":"Internal Module Categories","text":"right_module\nleft_module\nbimodule","category":"page"},{"location":"Constructions/ModuleCategories/#TensorCategories.right_module","page":"Internal Module Categories","title":"TensorCategories.right_module","text":"right_module(A::AlgebraObject)\n\nReturn A as the trivial right module\n\n\n\n\n\nright_module(M::BiModuleObject)\n\nReturn M as a right module forgetting the left module structure\n\n\n\n\n\n","category":"function"},{"location":"Constructions/ModuleCategories/#TensorCategories.left_module","page":"Internal Module Categories","title":"TensorCategories.left_module","text":"left_module(A::AlgebraObject)\n\nReturn A as the trivial left module\n\n\n\n\n\nleft_module(M::BiModuleObject)\n\nReturn M as a left module forgetting the right module structure\n\n\n\n\n\n","category":"function"},{"location":"Constructions/ModuleCategories/#TensorCategories.bimodule","page":"Internal Module Categories","title":"TensorCategories.bimodule","text":"bimodule(A::AlgebraObject)\n\nReturn A as the trivial bimodule\n\n\n\n\n\n","category":"function"},{"location":"Interface/TensorCategories/#Tensor-Categories","page":"Framework","title":"Tensor Categories","text":"","category":"section"},{"location":"Interface/TensorCategories/","page":"Framework","title":"Framework","text":"Let k be a field. Then a multitensor category is a category mathcal C which is","category":"page"},{"location":"Interface/TensorCategories/","page":"Framework","title":"Framework","text":"locally finite\nk-linear\nabelian\nrigid monoidal","category":"page"},{"location":"Interface/TensorCategories/","page":"Framework","title":"Framework","text":"such that","category":"page"},{"location":"Interface/TensorCategories/","page":"Framework","title":"Framework","text":"otimes is bilinear on morphisms.","category":"page"},{"location":"Interface/TensorCategories/","page":"Framework","title":"Framework","text":"We call a multitensor category ","category":"page"},{"location":"Interface/TensorCategories/","page":"Framework","title":"Framework","text":"tensor if additionally mathrmEnd(mathbb 1) = k,\nmultifusion if semisimple and finite and\nfusion if tensor, semisimple and finite.","category":"page"},{"location":"Interface/TensorCategories/","page":"Framework","title":"Framework","text":"Thus to implement a one of the above one simply has to implement the interfaces which are part of the definition.","category":"page"},{"location":"Interface/TensorCategories/#Multifusion-Categories","page":"Framework","title":"Multifusion Categories","text":"","category":"section"},{"location":"Interface/TensorCategories/","page":"Framework","title":"Framework","text":"Semisimple k-linear abelian categories have such a structure that allows one to describe them up to equivalence by matrices. Let X_i mid i in mathcal I be the set of non-isomorphic simple objects in mathcal C. This we can establish an equivalence ","category":"page"},{"location":"Interface/TensorCategories/","page":"Framework","title":"Framework","text":"mathcal C cong bigopluslimits_i  mathcal I mathrmVec_k","category":"page"},{"location":"Interface/TensorCategories/","page":"Framework","title":"Framework","text":"of abelian categories via X mapsto bigoplus mathrmHom(X_i X). For the detailed construction we refer to [2].","category":"page"},{"location":"Interface/TensorCategories/","page":"Framework","title":"Framework","text":"This basically implies that morphisms are merely matrices allowing us to efficiently compute thins like subobjects etc. Thus we want to choose any faithful functor ","category":"page"},{"location":"Interface/TensorCategories/","page":"Framework","title":"Framework","text":"F colon mathcal C to mathrmVec_k","category":"page"},{"location":"Interface/TensorCategories/","page":"Framework","title":"Framework","text":"to provide a method","category":"page"},{"location":"Interface/TensorCategories/","page":"Framework","title":"Framework","text":"matrix(f::YourMorphism)::MatElem.","category":"page"},{"location":"Interface/TensorCategories/","page":"Framework","title":"Framework","text":"This will open acces to the following operations which are necessary for many computations with fusion categories like for example the computation of the categorical center.","category":"page"},{"location":"Interface/TensorCategories/","page":"Framework","title":"Framework","text":"Modules = [TensorCategories]\nPages = [\"PentagonAxiom.jl\", \"HexagonAxiom.jl\"]","category":"page"},{"location":"Interface/TensorCategories/#TensorCategories.pentagon_axiom","page":"Framework","title":"TensorCategories.pentagon_axiom","text":"pentagon_axiom(objects::Vector{<:Object}, log::Bool = false)\n\nCheck the pentagon axiom for all combinations of objects in objects. If log = true an array with the failing combinations is returned\n\n\n\n\n\n","category":"function"},{"location":"Interface/TensorCategories/#TensorCategories.pentagon_axiom-2","page":"Framework","title":"TensorCategories.pentagon_axiom","text":"pentagon_axiom(C::Category, log::Bool = false)\n\nCheck the pentagon axiom for all combinations of  simple objects of C. If  log = true an array with the failing combinations is returned\n\n\n\n\n\n","category":"function"},{"location":"Interface/TensorCategories/#TensorCategories.pentagon_axiom-Union{Tuple{T}, NTuple{4, T}} where T<:Object","page":"Framework","title":"TensorCategories.pentagon_axiom","text":"pentagon_axiom(X::T, Y::T, Z::T, W::T) where T <: Object\n\nCheck the pentagon axiom for X, Y, Z, W.\n\n\n\n\n\n","category":"method"},{"location":"#TensorCategories.jl","page":"Home","title":"TensorCategories.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TensorCategories.jl is a software package based on the programming language Julia and the open-source computer algebra system Oscar.jl for computations with tensor categories. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You need to have Julia installed. For reliable results Julia version at least 1.6 is required. To use TensorCategories do the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\njulia> Pkg.add(url = \"https://github.com/FabianMaeurer/TensorCategories.jl\")","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use TensorCategories the structures from the OSCAR-System are required. Here a minimal usage example.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TensorCategories;\nI = Ising()\nC = center(Ising())\nS = smatrix(C)","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project was started under supervision of Prof. Ulrich Thiel  (University of Kaiserslautern). This work is a contribution to the SFB-TRR 195 'Symbolic Tools in Mathematics and their Application' of the German Research Foundation (DFG).","category":"page"},{"location":"Interface/BasicConstructions/#Basic-Categorical-Constructions","page":"Basic Consttructions","title":"Basic Categorical Constructions","text":"","category":"section"},{"location":"Interface/BasicConstructions/","page":"Basic Consttructions","title":"Basic Consttructions","text":"Let mathcal Cand mathcal D be categories.","category":"page"},{"location":"Interface/BasicConstructions/#Opposite-Category","page":"Basic Consttructions","title":"Opposite Category","text":"","category":"section"},{"location":"Interface/BasicConstructions/","page":"Basic Consttructions","title":"Basic Consttructions","text":"The opposite category mathcal C^op of mathcal C has the same objects and  morphisms fcolon  Y to X in mathrmHom_mathcal C^op(XY) formally switching domain and codomain.","category":"page"},{"location":"Interface/BasicConstructions/","page":"Basic Consttructions","title":"Basic Consttructions","text":"opposite_category\nopposite_object\nopposite_morphism","category":"page"},{"location":"Interface/BasicConstructions/#TensorCategories.opposite_category","page":"Basic Consttructions","title":"TensorCategories.opposite_category","text":"opposite_category(C::Category)\n\nConstruct the category Cᵒᵖ.\n\n\n\n\n\n","category":"function"},{"location":"Interface/BasicConstructions/#TensorCategories.opposite_object","page":"Basic Consttructions","title":"TensorCategories.opposite_object","text":"opposite_object(X::Object)\n\nRegard the object X  C as an object in Cᵒᵖ.\n\n\n\n\n\n","category":"function"},{"location":"Interface/BasicConstructions/#TensorCategories.opposite_morphism","page":"Basic Consttructions","title":"TensorCategories.opposite_morphism","text":"opposite_morphism(f::Morphism)\n\nRegard the morphism f  C as a morphism in Cᵒᵖ.\n\n\n\n\n\n","category":"function"},{"location":"Interface/BasicConstructions/#Product-Categories","page":"Basic Consttructions","title":"Product Categories","text":"","category":"section"},{"location":"Interface/BasicConstructions/","page":"Basic Consttructions","title":"Basic Consttructions","text":"Given a family of categories mathcal C_1mathcal C_n we can form the product category mathcal C = mathcal C_1 times cdots times mathcal C_n. Objects and morphism are just families of objects and morphisms. Structures all categories have and are preserved  by the product will be available.","category":"page"},{"location":"Interface/BasicConstructions/","page":"Basic Consttructions","title":"Basic Consttructions","text":"product_category\nproduct_object\nproduct_morphism","category":"page"},{"location":"Interface/BasicConstructions/#TensorCategories.product_category","page":"Basic Consttructions","title":"TensorCategories.product_category","text":"product_category(C::Category...)\n\nConstruct the product category\n\n\n\n\n\n","category":"function"},{"location":"Interface/BasicConstructions/#TensorCategories.product_object","page":"Basic Consttructions","title":"TensorCategories.product_object","text":"product_object(X::Object...)\n\nConstruct the product in the product category\n\n\n\n\n\n","category":"function"},{"location":"Interface/BasicConstructions/#TensorCategories.product_morphism","page":"Basic Consttructions","title":"TensorCategories.product_morphism","text":"product_morphism(f::Morphism...)\n\nConstruct the product morphism in the product category\n\n\n\n\n\n","category":"function"},{"location":"Interface/Philosophy/#The-Motivation","page":"Philosophy","title":"The Motivation","text":"","category":"section"},{"location":"Interface/Philosophy/","page":"Philosophy","title":"Philosophy","text":"This package began its journey asking the question \"Can we play around  with explicit categorical entities in the computer?\".","category":"page"},{"location":"Interface/Philosophy/","page":"Philosophy","title":"Philosophy","text":"By nature categorical operations and constructions are very generic and  can be applied as long as the objects (or morphisms) are fitting.  TensorCategories.jl provides an interface for categories with additional  structure, precisely additive, linear, abelian, monoidal, tensor and  fusion categories.","category":"page"},{"location":"Interface/Philosophy/#Realizing-Categories-in-The-Computer","page":"Philosophy","title":"Realizing Categories in The Computer","text":"","category":"section"},{"location":"Interface/Philosophy/","page":"Philosophy","title":"Philosophy","text":"Due to the nature of category theory the realization of certain categories  is very dependent on themselves. Thus the internal workings are generally  up to the developer. As long as the interface for the desired additional structures is implemented. ","category":"page"},{"location":"Interface/Philosophy/","page":"Philosophy","title":"Philosophy","text":"Some kind of categories, i.e. fusion categories, are entirely described (up to equivalence) by discrete data known as 6j-symbols. Thus  for such categories we can provide a datatype SixJCategory  to quickly work with categories given by such data.","category":"page"},{"location":"Interface/Philosophy/#Mathematical-Foundation","page":"Philosophy","title":"Mathematical Foundation","text":"","category":"section"},{"location":"Interface/Philosophy/","page":"Philosophy","title":"Philosophy","text":"Throughout the package we will consider definitions and terminology as provided in [1].","category":"page"}]
}
